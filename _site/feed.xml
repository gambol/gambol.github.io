<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gambol&#39;s Blog</title>
    <description></description>
    <link>http://gambol.github.io/</link>
    <atom:link href="http://gambol.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 05 Mar 2016 21:57:23 +0800</pubDate>
    <lastBuildDate>Sat, 05 Mar 2016 21:57:23 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>动态代理</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;动态代理&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;代理是什么？&lt;/h2&gt;
&lt;p&gt;在现实生活中，存在这样一种人—- 代理人。&lt;/p&gt;

&lt;p&gt;举一个例子，你目前在加州，看见现在北京的房产价格很高，想卖掉手头的房。怎么办呢？只能委托给你在国内的父母进行售卖。你作为业主，需要做的事情是：签合同。 因为你不能回国，所以，你父母就替你卖房。 当然，父母比你要操心更多。譬如带买家看房，选择一个靠谱的买家，还要把钱打给你。&lt;/p&gt;

&lt;p&gt;这个时候，父母就是你的代理。父母替你完成了许多你暂时不能（想）完成的工作&lt;/p&gt;

&lt;p&gt;在计算机世界里，也经常需要这种角色。为什么在代码里也需要这种角色呢？有几个优点：
1. &lt;strong&gt;职责清晰（核心角色只管签合同）&lt;/strong&gt;
2. &lt;strong&gt;扩展性好&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们先写一个代码看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface HouseSeller {

    boolean sell(int money, int peopleId);

    void signContract(int peopleId);

}

class $Young implements HouseSeller {

    @Override
    public boolean sell(int money, int peopleId) {

        if (money &amp;gt; 100) {
            System.out.println(&quot;ok, deal&quot;);
            return true;
        } else {
            System.out.println(&quot;no, i want more&quot;);
            return false;
        }
    }

    @Override
    public void signContract(int peopleId) {
        System.out.println(&quot;done. bye bye&quot;);
    }
}

class $Old implements HouseSeller {

    $Young young;

    public $Old($Young young) {
        this.young = young;
    }

    @Override
    public boolean sell(int money, int peopleId) {
        // 代理人替实体干活
        if (peopleId &amp;lt; 0) {
            System.out.printf(&quot;no, not a good man&quot;);
            return false;
        }

        return young.sell(money, peopleId);
    }

    @Override
    public void signContract(int peopleId) {
        // 找律师, 找房产证

        young.signContract(peopleId);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个代理里， Old就是Young的代理。代理通常做的事情如下图
&lt;img src=&quot;http://static.zybuluo.com/gambol/mbqa1aq4x6rmp9snudo1b471/43918004_9&quot; alt=&quot;代理所做的事情&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;## 动态代理又是什么？&lt;/p&gt;

&lt;p&gt;从上面的代码可以看出来，代理这种现象是存在的，也能解决不少问题。 但是明眼人都能看出来，上面的生成的那种代理（通常叫做静态代理）代码很罗嗦。&lt;/p&gt;

&lt;p&gt;懒惰的程序员又整出了一个新的模式，动态代理 ，用来解决&lt;em&gt;啰嗦代码&lt;/em&gt;。解决方案是什么呢？ 
第一招： 找了一个InvocationHandler来handle所有调用原始代码的地方。 
&lt;img src=&quot;http://static.zybuluo.com/gambol/v3zc4i205275a7rxsp3x02jl/43918004_10&quot; alt=&quot;InvocationHandler&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，如果想要InvocationHandler（或者说，代理）发挥作用，必须要Proxy和RealSubject能完成同样的功能。 怎么才能做到这个约定呢？ 有两种方案&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接口。 让Proxy 和RealSubject 实现同一个接口。（这就是JDK提供的动态代理机制）&lt;/li&gt;
  &lt;li&gt;继承。 让Proxy继承RealSubject。 这样Proxy就有了RealSubject的功能，还能改写RealSubject的功能呢。（这是cglib提供的代理机制）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;jdkinvocationhandler&quot;&gt;JDK默认动态代理（InvocationHandler）&lt;/h3&gt;

&lt;p&gt;使用这种机制之前，切记JDK的默认代理机制是基于&lt;strong&gt;接口&lt;/strong&gt;的，也就是说，需要被代理的类（RealSubject）必须要实现某个接口， 只有接口里的方法才能被代理生成。&lt;/p&gt;

&lt;p&gt;接着上面的代码，我们也用JDK默认的动态代理来写一个代码看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-JAVA&quot;&gt;
class Handler implements InvocationHandler {

    $Young young;

    public HouseSeller bind($Young young) {
        this.young = young;
        // 重点关注
        return (HouseSeller)Proxy.newProxyInstance(young.getClass().getClassLoader(), young.getClass().getInterfaces(), this);
    }

    // 重点关注
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {

        System.out.println(&quot;I am proxy: kakaka&quot;);

        return method.invoke(young, args);
    }


    // 真正调用的地方
    public static void main(String[] args) {
        Handler old = new Handler();

        HouseSeller seller = old.bind(new $Young());

        int peopleId = 3;
        int money = 200;
        if (seller.sell(money, peopleId)) {
            seller.signContract(peopleId);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点注意几个地方:
* 我们要新写一个代码, 实现&lt;code&gt;InvocationHandler&lt;/code&gt;接口. &lt;code&gt;InvocationHandler&lt;/code&gt;里,只有一个方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * proxy:　　指代我们所代理的那个真实对象
 * method:　　指代的是我们所要调用真实对象的某个方法的Method对象
 * args:　　指代的是调用真实对象某个方法时接受的参数
**/
public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Proxy.newProxyInstance&lt;/code&gt; 这个代码生成了真正的动态代理代码. 具体的实现代码见下&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;/**
 * loader:　　一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载
 *
 * interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
 *
 * h:　　一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上
**/

    public static Object newProxyInstance(ClassLoader loader,
                                          Class&amp;lt;?&amp;gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ................
        final Class&amp;lt;?&amp;gt;[] intfs = interfaces.clone();
        
        /*
         * 生成/找到 proxy class
         */
        Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面你的代码可以看出来, 使用InvocationHandler使用一个&lt;code&gt;invoke&lt;/code&gt;函数代替了之前的 &lt;code&gt;sell&lt;/code&gt;, &lt;code&gt;signContract&lt;/code&gt;函数. 恩,确实让大家懒惰了一些. (当然,JVM最后看到的代码, 仍然有&lt;code&gt;sell&lt;/code&gt;, &lt;code&gt;signContract&lt;/code&gt;.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cglib&quot;&gt;CGLIB&lt;/h3&gt;
&lt;p&gt;JDK的默认方法不错,但是有一个约束条件: 这个被代理的类,必须实现某个接口. 但是现实情况是,不是所有的想要被代理的类都实现了某个接口. 因此,这个时候CGLIB(Code Generation Library)诞生了.&lt;/p&gt;

&lt;p&gt;cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。&lt;/p&gt;

&lt;p&gt;还是接着写买房的代码, 我们看看使用CGLIB的情况下, 怎么写
```
class Hacker implements MethodInterceptor {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//要代理的原始对象
private Object obj;

public Object createProxy(Object target) {
    this.obj = target;
    // cglib里的增强类
    Enhancer enhancer = new Enhancer();

    // 设置代理目标
    enhancer.setSuperclass(this.obj.getClass());

    // 设置回调. 这是相当于代理类上的所有方法, 都会使用这个callback. callback使用intercept进行拦截
    enhancer.setCallback(this);

    return enhancer.create();
}


public Object intercept(Object paramObject, Method paramMethod, Object[] paramArrayOfObject, MethodProxy paramMethodProxy)
        throws Throwable {
    System.out.println(&quot;I am hacker go&quot;);
    Object o = paramMethodProxy.invokeSuper(paramObject, paramArrayOfObject);
    return o;
}

public static void main(String[] args) {
    $Young proxyYoung =  ($Young)new Hacker().createProxy(new $Young());

    int peopleId = 3;
    int money = 200;
    if (proxyYoung.sell(money, peopleId)) {
        proxyYoung.signContract(peopleId);
    }
} } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上文的代码可以看到CGLIB的核心是 Enhancer类,名字就霸气,叫做增强类. 在Spring的AOP很多生成的都是这种增强类.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;动态代理的机制是什么?&lt;/h2&gt;
&lt;p&gt;上文说了很多动态代理的写法. 我们回头来想一想, 为什么JVM在能支持动态代理,
InvocationHandler 和 cglib是怎么做到动态代理代码的生成的呢?&lt;/p&gt;

&lt;p&gt;通常情况下, JAVA编译器将.java文件编译成.class文件,.class文件里放的是JVM才能识别的机器码. JVM在运行时, 解释.class文件, 加载到内存里, 生成Class对象.&lt;/p&gt;

&lt;p&gt;这么说, 如果想要做动态代理, 其实只需要在运行时,生成对应的二进制文件(.class文件),传给JVM, JVM将这个文件解释,就动态的生成了一个Class对象.&lt;/p&gt;

&lt;p&gt;参考下图:
&lt;img src=&quot;http://static.zybuluo.com/gambol/3nqtusqrqv1nnwkcohed8dol/43918004_2&quot; alt=&quot;43918004_2-93.3kB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以利用工具 ASM 或者 javaassist来做生成 class的事情&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;动态代理有什么用&lt;/h2&gt;
&lt;p&gt;OK, 最后,我们来说一下, 代理有什么用.&lt;/p&gt;

&lt;p&gt;通常情况下, 我们都不裸着用代理. 常用代理的地方包括:
1. Spring的bean. 在Spring 上下文里, 所有的bean 都是代理之后的bean. 方便做一些功能的增强.
2. AOP.&lt;/p&gt;

&lt;p&gt;最后,说一个具体的例子.
需求是:  写一个方法, 执行这个方法时, 会调用所有有@A注解的类里的testXXX()方法.
解法 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以直接使用AspectJ来实现&lt;/li&gt;
  &lt;li&gt;也可以自己手写代码实现.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;http://www.360doc.com/content/14/0801/14/1073512_398598312.shtml&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 05 Mar 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/03/05/proxy/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/03/05/proxy/</guid>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>wireshark网络分析就这么简单读书笔记</title>
        <description>&lt;h1 id=&quot;wireshark&quot;&gt;wireshark网络分析就这么简单&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;更新记录&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;v1 2016.2.28&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;写在前面的话&lt;/h2&gt;
&lt;p&gt;虽然我07年在计算所分析网络协议时，就用了wireshark的前身Ethereal， 但是没有想到16年的今天，还会读这个书。这个书是同事liuyue推荐我读的，很薄的一本书。两天看完。&lt;/p&gt;

&lt;p&gt;07年做网络协议抓包分析时， 还有一个其他的选择叫CommView。 如果拿CommView和Wireshark做一个比较的话， Wireshark像是Photoshop，功能强大；CommView像是美图秀秀，使用方便简单。&lt;/p&gt;

&lt;p&gt;这本书主要介绍了都是实用示例，不太好单独摘录出来。我挑选主要学习到的知识点来说吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;知识点&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;子网、网关、子网掩码&lt;/h3&gt;

&lt;p&gt;两台电脑之间通信，有两种可能性。
- 在同一个局域网（也叫子网）内
通过ARP协议，通过IP找到MAC地址，直接通信
- 不在同一个局域网内
通过网关做转发，来进行通信&lt;/p&gt;

&lt;p&gt;如何判断两个电脑(A和B）是不是在同一个局域网内呢？
如果A向B进行通信， 则
用A的IP地址 &amp;amp; A的网关   与 B的IP地址 &amp;amp; A的网关&lt;/p&gt;

&lt;h3 id=&quot;tcp&quot;&gt;TCP重传&lt;/h3&gt;
&lt;p&gt;TCP拥塞控制和重传，是TCP协议最难的地方。如果网络性能有问题，可以看看重传和拥塞（当然，前提是查看网络是否丢包）&lt;/p&gt;

&lt;p&gt;滑动窗口： 由接收端在ACK包里告诉发送端，还有多大的窗口可以传输。  滑动窗口的大小是可以调整的。&lt;/p&gt;

&lt;p&gt;超时重传: 接收端发送一个包之后， 会启动一个定时器。在一段时间没有收到某个包的ACK时， 重传这个包。 重传时间设置非常影响性能。
为了减少重传时间的影响，有一个快重传协议：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。&lt;/p&gt;

&lt;p&gt;拥塞控制： 防止网络异常时，发更多的包，加剧网络的异常。 算法核心是，改变滑动窗口的大小 一般 方案是： 慢启动+拥塞避算法。
拥塞控制算法非常多，目前linux用的是cubic。 请看下面的图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/g2aqml2v62myx3hdnd2zigxo/SouthEast.jpeg&quot; alt=&quot;拥塞控制算法&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Feb 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/02/28/wireshark/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/02/28/wireshark/</guid>
        
        <category>读书笔记</category>
        
        <category>网络</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>乱序执行</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;乱序执行 以及 原子操作&lt;/h1&gt;

&lt;p&gt;标签（空格分隔）： 技术 优化 锁 乱序&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;[toc]&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编译器优化&lt;/h2&gt;
&lt;p&gt;为了提高执行效率, 在不影响执行结果的情况下, 编译器会任意重排代码顺序, 生成重排之后的汇编代码.&lt;/p&gt;

&lt;h2 id=&quot;cpu&quot;&gt;cpu乱序是什么&lt;/h2&gt;
&lt;p&gt;同样为了提升执行效率, CPU也可能不按照汇编层面的顺序来执行,前提是不影响语义.&lt;/p&gt;

&lt;p&gt;譬如&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a = 1;
b = 2;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上这段代码,可能并不会按照顺序执行. 如果b 恰好在cpu0的cache里的时候, 就会先执行&lt;code&gt;b = 2&lt;/code&gt; 这句话.&lt;/p&gt;

&lt;p&gt;还举一个例子,如果某条语句在阻塞的情况下, cpu可能会执行一条上下文无关的代码,以此提高cpu的使用效率.&lt;/p&gt;

&lt;h3 id=&quot;cpu-1&quot;&gt;CPU是怎么做的呢?&lt;/h3&gt;
&lt;p&gt;CPU有很多cache一致性的协议, 比较有名的是MESI协议.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;原子操作&lt;/h2&gt;
&lt;p&gt;原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行倒结束，中间不会有任何 context switch （切换到另一个线程）。&lt;/p&gt;

&lt;h3 id=&quot;cpu-2&quot;&gt;CPU如何实现原子操作&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本身自带原子操作
新的cpu保证,在缓存读16/32/64位的操作是原子的&lt;/li&gt;
  &lt;li&gt;总线锁
CPU提供一个LOCK信号, 当一个CPU向总线输出这个信号时,其他CPU向总线的请求会被阻塞&lt;/li&gt;
  &lt;li&gt;缓存锁
只锁住某个缓存(cpu cache)内的数据,不会同时被多个CPU访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;JAVA如何实现原子操作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CAS
自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止&lt;/li&gt;
  &lt;li&gt;锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;http://www.infoq.com/cn/articles/java-se-16-synchronized&lt;/li&gt;
  &lt;li&gt;https://www.zhihu.com/question/36293510&lt;/li&gt;
  &lt;li&gt;http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 22 Feb 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/02/22/atom/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/02/22/atom/</guid>
        
        <category>技术</category>
        
        <category>乱序</category>
        
        
      </item>
    
      <item>
        <title>PAXOS协议介绍</title>
        <description>&lt;h1 id=&quot;paxos&quot;&gt;PAXOS&lt;/h1&gt;

&lt;p&gt;标签（空格分隔）： 技术 分布式&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;paxos--&quot;&gt;paxos 是什么, 解决什么问题&lt;/h1&gt;
&lt;p&gt;Paxos算法是莱斯利·兰伯特（英语：Leslie Lamport，LaTeX中的“La”）于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。&lt;/p&gt;

&lt;p&gt;在分布式系统中, 节点通信主要依靠两种模型. 共享内存 和 消息传递.  如果基于消息传递,必然会有各种问题: 譬如 进程变慢, 重启,消息丢失.为了解决消息传递里的问题, 就出现了一致性算法.&lt;/p&gt;

&lt;p&gt;paxos算法解决的问题是: 在分布式系统中保证某个值达成一致.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;# 常见场景是什么?
paxos的典型的场景是用在分布式数据库系统中.&lt;/p&gt;

&lt;p&gt;我们通常认为, 在分布式系统中,如果每个节点的初始状态一致, 并且执行相同的操作, 那么最后可以得到一致的结果.
为了得到这个相同的命令, 需要在每一条指令上,执行”一致性算法”, 保证每个节点看到的指令相同.&lt;/p&gt;

&lt;p&gt;具体来说, 可能的场景包括
1. 数据库的数据复制. 保持多个节点数据的一致性
2. naming service (zookeeper的经典功能)
    naming service 是指, 在集群里, 经常会需要有地方能够存hostname/ip映射关系, 服务名和服务地址映射等等. 如果单机在每台机器上存放这些信息,随着系统的变大, 可能会出现信息不一致. 
   于是有一种做法是提供集中式的naming service服务.
   于是也可以分布式的服务. 这种场景时, 可以使用paxos
3. config配置管理 (zookeeper经典的功能)
4. id分配.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;paxos-&quot;&gt;paxos 有什么类似的选择,各有什么优缺点&lt;/h1&gt;
&lt;p&gt;如果目的是比较分布式数据存储,有以下解决方案.(严格意义上来说, 这一篇不算是paxos 同类产品的比较)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;算法&lt;/th&gt;
      &lt;th&gt;简单介绍&lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;master/slave&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;成熟稳定&lt;/td&gt;
      &lt;td&gt;master还是会有单点故障&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;multi master&lt;/td&gt;
      &lt;td&gt;一个系统多个master, 每个master都有read-write的能力&lt;/td&gt;
      &lt;td&gt;解决了master slave的单点问题&lt;/td&gt;
      &lt;td&gt;合并版本比较复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;两阶段提交(Two phase commit)&lt;/td&gt;
      &lt;td&gt;第一个阶段,锁定所有的参与者的资源. 第二个阶段, 通知所有的参与者.&lt;/td&gt;
      &lt;td&gt;相对简单&lt;/td&gt;
      &lt;td&gt;1. 需要阻塞. 2, 容错机制较差&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三阶段提交 (Three phase commit)&lt;/td&gt;
      &lt;td&gt;针对两阶段提交容错机制差的问题, 做了改进. 分成vote, pre commit, commit 三个阶段. &lt;img src=&quot;https://upload.wikimedia.org/wikipedia/en/3/39/Three-phase_commit_diagram.png&quot; alt=&quot;三阶段commit&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;不会由于单点故障,出现问题&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;paxos&lt;/td&gt;
      &lt;td&gt;在三阶段提交的基础上, 分成了6个步骤,纤细看下文&lt;/td&gt;
      &lt;td&gt;目前最完整的一致性算法&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;paxos--1&quot;&gt;paxos 有什么关键技术,解决他的问题&lt;/h1&gt;
&lt;p&gt;paxos算法里, 分成3种角色
1. 提案者.  两个作用, 1) 拿到提案编号, 2)做提案
2. 决策者.  决策究竟使用哪个提案,
3. 书记官.  记录提案的执行结果&lt;/p&gt;

&lt;p&gt;主要的步骤包括
1. &lt;strong&gt;提案者&lt;/strong&gt;生成唯一编号N. 向50%以上的决策者发出预提案请求P
2. 被发送消息的&lt;strong&gt;决策者&lt;/strong&gt;收到提案请求P, 对应编号N.  &lt;strong&gt;决策者&lt;/strong&gt;查看自己关于时间P,是否有收到过提案.  分成三种情况
a) 没有收到过提案, 返回&lt;em&gt;通过&lt;/em&gt;
b) 已经收到过提案, 提案编号为M. 如果M大于N, 则返回&lt;em&gt;拒绝&lt;/em&gt;
c) 如果M&amp;lt;N, 返回 &lt;em&gt;“通过, 但是哥收到过M”&lt;/em&gt;
3. &lt;strong&gt;提案者&lt;/strong&gt;如果收到的都是通过, 则可以正式提议了.
   如果收到了一个”拒绝”, 则提案被拒绝
   如果收到了”通过,但是哥收到过M”, 提案者用收到的所有M中最大值, 重新提案, 回到第一步
4. &lt;strong&gt;提案者&lt;/strong&gt;正式提议. &lt;strong&gt;决策者&lt;/strong&gt; 类似于第二步, 重新选择通过或者拒绝
5. &lt;strong&gt;提案者&lt;/strong&gt;如果发现提案被50%以上的&lt;strong&gt;决策者&lt;/strong&gt;同意了, 则决策通过. 通知&lt;strong&gt;书记官&lt;/strong&gt;, 记录这条法令. 如果不够50%的决策者赞成, &lt;strong&gt;提案者&lt;/strong&gt;接着找其他的&lt;strong&gt;决策者&lt;/strong&gt;来决策. 有任一&lt;strong&gt;决策者&lt;/strong&gt;返回&lt;em&gt;拒绝&lt;/em&gt;, 提案终止
6. &lt;strong&gt;书记官&lt;/strong&gt;记录这条法案&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section&quot;&gt;参考文献&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://timyang.net/distributed/paxos-scenarios/&quot;&gt;paxos 在分布式系统中的应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cxwangyi.wordpress.com/2013/10/17/cluster-name-service/&quot;&gt;naming service 的介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95&quot;&gt;paxos wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zybuluo.com/Spongcer/note/63033&quot;&gt;Consitency&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://codemacro.com/2014/10/15/explain-poxos/&quot;&gt;解释paxos原理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 18 Feb 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/02/18/PAXOS/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/02/18/PAXOS/</guid>
        
        <category>分布式</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>比特币</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;比特币&lt;/h1&gt;

&lt;p&gt;标签（空格分隔）： 经济 电子货币 投资&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-1&quot;&gt;比特币是什么? 解决什么问题&lt;/h1&gt;
&lt;p&gt;比特币是一种数字货币，可以在用户之间进行交易，出现于2009年，据说总量只有2100w 货币的本质是用来交易，是一般等价物。只要大家愿意相信这个物品的价值，那他就可以成为货币。&lt;/p&gt;

&lt;p&gt;白话一点说，比特币的出现是这样的， 突然有一天，上帝说，我这里有100w个贝壳，每个人都来我这里领吧，先到先得， 你们以后就用我给你们的备课进行交易哦。 A从上帝手中领了100个贝壳回家，B领了20个回家。
每发出一个贝壳， 上帝就在账本里记录了一笔.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2016-1-19， A领了100个贝壳&lt;/li&gt;
  &lt;li&gt;2016-1-20， B领了20个贝壳&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是A和B就用这些贝壳进行交易。 有一天，A饿了，用5个贝壳跟B换了一斤大米。 于是上帝记录了一笔
 - 2016-1-21, A的贝壳数减少5个，A有95个贝壳
 - 2016-1-21, B的贝壳数增加5个，B有25个贝壳&lt;/p&gt;

&lt;p&gt;这种日子过了一阵子之后，上帝累了，不想记账本，于是他把账本复制了很多份，发给了每一个居民。上帝告诉居民说，以后你们和其他交易后，自己大喊一声，告诉别的所有人。 当你们听见了别人大喊一声时，也记录下来这个交易。 和别人交易时，先看看自己的账本，看对方有没有钱就行了。  —– 于是， 去中心化的货币就出现了。&lt;/p&gt;

&lt;p&gt;有过了一阵子，居民发现说，每天带着贝壳上街太麻烦了，反正账本里有所有人的贝壳数目，交易之前看看账本就好了。于是，比特币出现了。&lt;/p&gt;

&lt;p&gt;比特币解决的问题主要是
1. 去中心化。 不依赖于某一个组织，而是由全体比特币持有者来决定
2. 利润上这种去中心化的体系，能提高效率。 牛逼的电子货币体系，使用起来，比银行转账方便。然而我在使用过程中发现，每笔交易延迟约5-10分钟。（这也是为什么莱特币出来的原因）
3. 总量恒定，可以有效防止上帝心血来潮增加货币数量。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-2&quot;&gt;比特币有什么对手, 各有什么优缺点&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;一般等价物&lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;黄金&lt;/td&gt;
      &lt;td&gt;天生的一般等价物，人类的基因缺陷&lt;/td&gt;
      &lt;td&gt;太重了，不方便随身携带。交易困难&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;纸币 / 银行卡&lt;/td&gt;
      &lt;td&gt;解决黄金“太重“的问题&lt;/td&gt;
      &lt;td&gt;政府来做担保。如果政府不靠谱，纸币、银行卡就是废&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;比特币&lt;/td&gt;
      &lt;td&gt;比纸币高级一点，去中心化，符合互联网特征。&lt;/td&gt;
      &lt;td&gt;缺乏信用担保，不是每个人都信它。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;莱特币&lt;/td&gt;
      &lt;td&gt;比比特币快，价钱更便宜&lt;/td&gt;
      &lt;td&gt;比比特币信用更差&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-3&quot;&gt;比特币有什么关键的技术吗?&lt;/h1&gt;

&lt;p&gt;比特币的设计者（中本聪）简直是一个天才（耶稣？）。一个很简单的事实是，他一个人设计出来的比特币席卷了全球，但是全世界的人却不知道他本人是谁。 比特币的源代码完全公开，现在仍然没有人发现比特币体系的漏洞。 关键的技术包括&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;区块 &amp;amp;&amp;amp; 区块链&lt;/h2&gt;
&lt;p&gt;整个体系里最重要的技术，就是区块链。&lt;/p&gt;

&lt;p&gt;区块链（block chain）类似于比特币系统中的账本。区块链是一群分散的客户端节点，并由所有参与者组成的分布式数据库，是对所有比特币交易历史的记录[16]。&lt;/p&gt;

&lt;p&gt;首先介绍一个概念，什么是区块。一段时间内的交易打成的一个包称为区块。区块依次链接到上一个区块，形成区块链。区块按照顺序排列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/o0qu4y66hcbhsgkszjoobrnq/f0897491c2069e307e0abcaa58e6808b_b%20%281%29.png&quot; alt=&quot;f0897491c2069e307e0abcaa58e6808b_b (1).png-35.5kB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每当有用户产生交易后，用p2p的技术，通知全世界所有的block chain里写上这条记录。譬如，A有区块1-20，同时A发现B最大区块是15，于是A就会把16-20的区块同步给B&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;挖矿&lt;/h2&gt;
&lt;p&gt;比特币是一个p2p的世界。为了鼓励有更多的人保持在线，维护“账本”，中本聪设计了“挖矿”的功能。
只要谁打包交易信息，生成了一个区块，谁就能得到一定的比特币作为奖励。— 这就是挖矿&lt;/p&gt;

&lt;p&gt;因为有很明显的奖励机制（2016年初，每个比特币价值是2500 rmb，目前生成一个区块，大概奖励15个比特币），因此有大量的节点想来生成区块。为了保证区块的唯一性，比特币决定：最先生成符合比特币规则的区块就能获得这个区块的打包权。 规则大概是：SHA-256一次，如果生成的字符串里，从第一位开始，如果有足够多个连续的0，那么就OK拉。 当某个节点生成了一个区块，那么这个节点赶快发消息通知所有节点，区块已经生成。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-6&quot;&gt;比特币前景怎么样&lt;/h1&gt;
&lt;p&gt;这部分内容是个人想的，不代表权威。 
## 2016-1-21版本
比特币的优势很明显： 
1. 设计者是个天才，并且这个天才有很多的拥护者
2. 数字化货币是历史的趋势，符合互联网的精神
3. 在虚拟货币里，比特币目前信誉还不错&lt;/p&gt;

&lt;p&gt;比特币相对来说劣势包括：
1. 没有信用人给做担保，所以目前人们还有担心。
2. 比特币的封闭性（只有2100w个比特币），很适合庄家炒作。譬如，如果现在有人买了50%的比特币，社会上流通的比特币会变少，于是比特币就更加值钱，庄家手头的比特币也得到了增值。
3. 政府（或者既得利益者）的反抗。去中心化之后，银行和政府收到的冲击最大。
4. 后来者心里不平衡。 09年早期时，随便是个人，就有几万个比特币。到现在，几万个比特币价值几千万 rmb。 又给了整个社会一次财富不平均的机会&lt;/p&gt;

&lt;p&gt;总体来说，目前比特币还在观望中，可以少量的投资。对于我来说，如果16年年底慢慢长到了5k rmb /btc，或者16年之内，由于政府势力造成比特币跌到 现在的1/3（每个比特币 800 rmb）, 可能可以入手。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;2016-1-24&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;另外，需要持续关注其他形式的货币，尤其是某些政府（或者较权威组织）参与的其他形式的货币。很可能是一次新的变革&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;参考文章&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.zhihu.com/question/22076666&lt;/li&gt;
  &lt;li&gt;https://blockchain.info/wallet/new wdb1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的收款吗： 17BmdGmuiwTDR815S78pzFTuiSEKmUxjXF&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/01/29/bitcoin/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/01/29/bitcoin/</guid>
        
        <category>经济</category>
        
        <category>投资</category>
        
        
      </item>
    
      <item>
        <title>原油投资</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;原油投资&lt;/h1&gt;

&lt;p&gt;标签（空格分隔）： 经济 投资 原油&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-1&quot;&gt;原油价格趋势&lt;/h1&gt;
&lt;p&gt;从14年7月份最高的107块，2015年1月时，跌倒了47usd 每桶。2015年16月涨到了一个高点，60块。 2016年1月份跌倒了现在的32块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/l8p5j3wqxsq91hopp6914c14/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-24%20%E4%B8%8B%E5%8D%8810.10.35.png&quot; alt=&quot;屏幕快照 2016-01-24 下午10.10.35.png-91.9kB&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;原油价格下跌的原因&lt;/h1&gt;
&lt;p&gt;原油术语寡头垄断市场结构。控制价格的主要原因不是市场供需，而是供应商（opec）的主观意愿。猜测opec借石油降价打击美国或者其他国家的石油产业。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-3&quot;&gt;原油是否有投资价值&lt;/h1&gt;
&lt;p&gt;长远来看，能源是稀缺品，预计在核能广泛民用之前，石油是最靠谱的能量来源。32一桶的价格绝对是低估。
如果是不急用的钱，做长期投资，目前这个价格风险不大。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-4&quot;&gt;如何投资&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;直接买入原油期货、期权等衍生品&lt;/li&gt;
  &lt;li&gt;买etf。 不带杠杆的有：石油指数ETF-美国(USO) ，  United States Brent Oil ETF(BNO)  。 带杠杆的有$VelocityShares 3x Long Crude Oil ETN(UWTI)。&lt;/li&gt;
  &lt;li&gt;买俄罗斯股票或者俄股etf， 譬如俄罗斯ETF-Market Vectors(RSX)，   Qiwi(QIWI) ， Yandex(YNDX)  ， XDB俄罗斯(03027)。 不过存在一定的政策风险。&lt;/li&gt;
  &lt;li&gt;没有ib账号的，可以买入工行纸原油。 缺点是，点差大&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;# 参考文献
1. ib 交易原油期货的方法：http://xueqiu.com/4586203773/30270387
2. http://xueqiu.com/S/UCO
3. 原油趋势： http://finance.sina.com.cn/futures/quotes/CL.shtml&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/01/24/oil/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/01/24/oil/</guid>
        
        <category>投资</category>
        
        <category>经济</category>
        
        
      </item>
    
      <item>
        <title>流量控制</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;流量控制&lt;/h1&gt;

&lt;p&gt;标签（空格分隔）： 技术 流量控制 限速&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-1&quot;&gt;作用&lt;/h1&gt;
&lt;p&gt;流量控制的作用那可就多了, 实用场景非常多. 譬如 某个接口抗不了太大的压力,最好增加一个限制, 譬如qps不超过10.&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;实现&lt;/h1&gt;
&lt;p&gt;## 简单实现
最简单的做法是维护一个单位时间内的Counter，如判断单位时间已经过去，则将Counter重置零。 这种方法的问题是, 不能在连续的时间里,保证流量控制. 因此出现了漏斗的算法&lt;/p&gt;

&lt;h2 id=&quot;bucket&quot;&gt;bucket算法&lt;/h2&gt;
&lt;p&gt;有两种常见的bucket算法. 第一种算法是
### Leaky Bucket
思想是认为有一个会漏水的桶，水以恒定速率滴出，上方会有水滴（请求）进入水桶。显然，如果上方水滴进入速率超过水滴出的速率，那么水桶就会溢出，这里的溢出就是traffic shaping和traffic policing的条件，即执行某个过载任务的时候。&lt;/p&gt;

&lt;p&gt;可以参考 wiki上的这个链接. https://en.wikipedia.org/wiki/Leaky_bucket&lt;/p&gt;

&lt;p&gt;引用&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/4/4c/Leaky_bucket_as_a_meter-policing.JPG&quot; alt=&quot;leaky bucket&quot; /&gt;&lt;/p&gt;

&lt;p&gt;java 代码实现请看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; /**
 * 水溜走的速度(相当于允许最大的速率)
 */
long rate;

/**
 * 桶子的大小
 */
long bucketSize;

/**
 * 上次运行的时间
 */
long lastCalcTime;

/**
 * 可以接纳的容量
 */
long water;

public LeakyBucketLimiter(long bucketSize, long rate) {
    this.rate = rate;
    this.bucketSize = bucketSize;
}

synchronized boolean take() {
    long now = System.currentTimeMillis();
    water = Math.max(water - (now - lastCalcTime) * rate / 1000, 0);
    lastCalcTime = now;

    if (water &amp;lt; bucketSize) {
        water++;
        return true;
    }

    return false;
}

public static void main(String[] args) throws Exception {
    LeakyBucketLimiter limiter = new LeakyBucketLimiter(5, 5);

    for(int i = 0; i &amp;lt; 20; i++) {
        boolean result = limiter.take();
        logger.info(&quot;runtime :{},  result:{}&quot;, i, result);
    }

    Thread.sleep(1000);

    for(int i = 0; i &amp;lt; 20; i++) {
        boolean result = limiter.take();
        logger.info(&quot;second time runtime :{},  result:{}&quot;, i, result);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;token-bucket&quot;&gt;token bucket&lt;/h2&gt;
&lt;p&gt;token bucket 和 leaky bucket 基本相同, 思路更加符合人的想法.
同样有一个桶，令牌以恒定速率放入桶，桶内的令牌数有上限，每个请求会acquire一个令牌，如果某个请求来到而桶内没有令牌了，请说明这个请求是过载的。和Lecky Bucket不同的是，Token Bucket存在burst rate。比如当前令牌放入速率4个每秒，桶的令牌上限是8，第一秒内没有请求，第二秒实际就可以处理8个请求！虽然平均速率还是4个每秒，但是爆发速率是8个每秒。&lt;/p&gt;

&lt;p&gt;用图片表示, 思路如下:
&lt;img src=&quot;http://ww4.sinaimg.cn/large/56d8760agw1f04rnswvz8j20bp06pwek.jpg&quot; alt=&quot;token bucket&quot; /&gt;&lt;/p&gt;

&lt;p&gt;wiki地址是
https://en.wikipedia.org/wiki/Token_bucket&lt;/p&gt;

&lt;p&gt;代码也比较简单, 请看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 最大允许的token数量
 */
double maxAllowedToken;

/**
 * 现有的空闲token数量
 */
double availableToken;

/**
 * 下一个可以使用token的时间
 */
long lastCalcTime;

/**
 * 每秒增加的token数量
 */
double tokenPerSecond;


public TokenBucketLimiter(double maxAllowedToken, double tokenPerSecond) {
    this.maxAllowedToken = maxAllowedToken;
    this.tokenPerSecond = tokenPerSecond;
}


synchronized boolean take() {
    long now = System.currentTimeMillis();
    availableToken = Math.min(availableToken +  (now - lastCalcTime) * tokenPerSecond / 1000.0, maxAllowedToken);
    lastCalcTime = now;

    if (availableToken &amp;gt;= 1) {
        availableToken --;
        return true;
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;token-bucket--leaky-bucket&quot;&gt;token bucket 与 leaky bucket比较&lt;/h2&gt;
&lt;p&gt;Leacky Bucket算法默认一开始水桶是空的，可以立即就接收最多burst的请求，而Token Bucket就要设置初始Token的数量。
其他方面,这两个差不多.&lt;/p&gt;

&lt;h2 id=&quot;ratelimiter&quot;&gt;RateLimiter&lt;/h2&gt;
&lt;p&gt;google guava有一个token bucket的实现, 他在这个基础上,增加了很多工业上的优化. 源码解释可以参考 &lt;a href=&quot;http://xiaobaoqiu.github.io/blog/2015/07/02/ratelimiter/&quot;&gt;guava ratelimiter 源码解释&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ratelimiter-1&quot;&gt;分布式的rateLimiter实现&lt;/h2&gt;
&lt;p&gt;基于redis的基础上, 我写了一个分布式环境下的rate limiter, 利用redis, 简单写了一个基于token bucket的算法. 这个代码代码有一个缺陷, 使用了redis的事务. 但是redis的事务有一些缺陷.并且还有一些代码没有写完整, 将来再补充.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private final Object mutex = new Object();

public static RateRestrainer createRedisRestrainer(double rate, String redisKey, JedisPool jedisPool) {
    return new RedisTokenBucket(rate, redisKey, jedisPool);
}

/**
 * 返回现在限制的最大速度
 *
 * @return
 */
public final double getRate() {
    // TODO 增加实现
    return 0.0;
}

/**
 * 获取执行这条记录的permit。 如果获取不到，一直睡眠，直到获取成功
 */
public double acquire() {
    long stepIntoTime = Ticker.read();
    ReserveResult reserveResult;

    do {
        synchronized (mutex) {
            reserveResult = reserveTicket();
        }
        Ticker.sleep(reserveResult.getMillsToWait());
    } while (reserveResult.continueWait);

    long stepOutTime = Ticker.read();
    return 1.0 * (stepOutTime - stepIntoTime);
}

// TODO
public double tryAcquire() {
    return 0.0;
}

// 尝试去获取一个许可。
abstract ReserveResult reserveTicket();

private static class RedisTokenBucket extends RateRestrainer {

    /**
     * 最大允许的token数量
     */
    double maxAllowedToken;

    /**
     * 现有的空闲token数量
     */
    double availableToken;

    /**
     * 每秒增加的token数量
     */
    double tokenPerSecond;

    /**
     * jedis的pool
     */
    private JedisPool pool;

    /**
     * jedis template。封装了一些jedis的操作
     */
    private JedisTemplate jedisTemplate;

    /**
     * redis 要用到的key的prefix
     */
    private String redisKey;

    final static String AVAILABLE_TOKEN = &quot;availableToken&quot;;
    final static String LAST_REFRESH_TIME = &quot;lastRefreshTime&quot;;

    public RedisTokenBucket(double rate, String redisKey, JedisPool jedisPool) {
        tokenPerSecond = rate;
        this.redisKey = redisKey;
        pool = jedisPool;
        maxAllowedToken = rate;
        availableToken = 0;
        jedisTemplate = new JedisTemplate(jedisPool);
        clearRedis();
    }

    @Override
    ReserveResult reserveTicket() {
        final Jedis jedis = pool.getResource();
        jedis.watch(redisKey);

        double availableTokenInRedis = getDoubleFromRedis(AVAILABLE_TOKEN);
        long lastRefreshTimeInRedis = getLongFromRedis(LAST_REFRESH_TIME);
        long timeInRedisMills = fetchRedisTimeMills();

        boolean flag = false; // 运行结果
        try {
            final Transaction transaction = jedis.multi();

            availableToken = Math.min(availableTokenInRedis + (timeInRedisMills - lastRefreshTimeInRedis)
                    * tokenPerSecond / TimeUnit.SECONDS.toMillis(1L), maxAllowedToken);
            transaction.hset(redisKey, LAST_REFRESH_TIME, String.valueOf(timeInRedisMills));

            if (availableToken &amp;gt;= 1) {
                availableToken--;
                flag = true;
            }

            transaction.hset(redisKey, AVAILABLE_TOKEN, String.valueOf(availableToken));
            List&amp;lt;Object&amp;gt; resultList = transaction.exec();

            if (CollectionUtils.isEmpty(resultList)) {
                flag = false; // redis提交失败， 说明别的进程/线程在这次提交之前先运行了。这次申请失败
            }
        } finally {
            pool.returnResource(jedis);
        }

        if (!flag) {
            long sleepFor = Math.round(TimeUnit.SECONDS.toMillis(1L) * (1.0 - availableToken) / tokenPerSecond);
            return ReserveResult.createWaitResult(sleepFor);
        }
        return ReserveResult.createContinueResult();
    }

    /**
     * 清掉redis里的这个key对应的值
     */
    void clearRedis() {
        jedisTemplate.del(redisKey);
    }

    /**
     * 获取redis所在机器的系统时间。 单位是ms
     *
     * @return 时间
     */
    long fetchRedisTimeMills() {
        /**
         * 给默认值
         */
        long timeInRedis = Ticker.read();
        try {
            List&amp;lt;String&amp;gt; timeList = jedisTemplate.execute((Jedis jedis) -&amp;gt; jedis.time());
            timeInRedis = Long.parseLong(timeList.get(0)) * 1000 + Long.parseLong(timeList.get(1)) / 1000;
        } catch (NullPointerException | NumberFormatException | IndexOutOfBoundsException e) {
            logger.error(&quot;error in parse time. use system time&quot;, e);
        }
        return timeInRedis;
    }

    /**
     * 从redis 的hash 里 取出相应field的值，转换成double。 如果转换失败（譬如为null，或者这个值不为double），则返回0
     *
     * @return double值
     */
    double getDoubleFromRedis(String field) {
        double ret = 0.0;
        String v = jedisTemplate.hget(redisKey, field);
        try {
            ret = v != null ? Double.parseDouble(v) : 0.0;
        } catch (NumberFormatException | NullPointerException e) {
            logger.warn(&quot;error in parseDouble.key:{}, field:{}&quot;, redisKey, field, e);
        }
        return ret;
    }

    long getLongFromRedis(String field) {
        long ret = 0;
        String v = jedisTemplate.hget(redisKey, field);
        try {
            ret = v != null ? Long.parseLong(v) : 0;
        } catch (NumberFormatException e) {
            logger.warn(&quot;error in parseLong.key:{}, field:{}&quot;, redisKey, field, e);
        }

        return ret;
    }
}

@Getter
@Setter
@AllArgsConstructor
final static class ReserveResult {
    /**
     * 这次睡眠的时间，单位为 毫秒
     */
    long millsToWait;

    /**
     * 是否需要继续等待
     */
    boolean continueWait;

    /**
     * 预定成功，继续运行
     */
    final static ReserveResult CONTINUE_RESULT = new ReserveResult(0, false);

    /**
     * 创建一个需要等待的对象
     *
     * @param millsToWait
     * @return
     */
    static ReserveResult createWaitResult(long millsToWait) {
        return new ReserveResult(millsToWait, true);
    }

    /**
     * 不需要等待
     *
     * @return
     */
    static ReserveResult createContinueResult() {
        return CONTINUE_RESULT;
    }
}

/**
 * 计时器.
 */
final static class Ticker {

    /**
     * @return 获取当前时间戳。 单位是 ms
     */
    static long read() {
        return System.currentTimeMillis();
    }

    static void sleep(long millsToSleep) {
        if (millsToSleep &amp;gt; 0) {
            Uninterruptibles.sleepUninterruptibly(millsToSleep, TimeUnit.MILLISECONDS);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sun, 03 Jan 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/01/03/traffic-control/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/01/03/traffic-control/</guid>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>HIVE原理介绍</title>
        <description>&lt;h1 id=&quot;hive&quot;&gt;hive&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;hive-1&quot;&gt;HIVE是什么&lt;/h1&gt;
&lt;p&gt;基于hadoop的查询工具,方便把结构的数据文件序列化成一张数据库表. 允许开发人员把sql语句转成MapReduce任务运行.&lt;/p&gt;

&lt;h1 id=&quot;hive-2&quot;&gt;和HIVE类似的东西是什么,各有什么优缺点&lt;/h1&gt;
&lt;p&gt;|  名字 | 优点 |  缺点  | 适用场景 |
| ——–| —–| —–| –|
| hive |  和hadoop原生集成 | 慢,性能低  |  绝大部分场景 |
| Cloudera Impala| 不用MapReduce进行查询, 适用自己的守护进程| 需要自己的特定的文件格式,还需要Imala守护进程 | 需要更快查询|
|Presto | 和Impala类似 | 除了Impala的缺点之外.还多一点:没有大公司支持| 既要速度, 而且自己够牛逼|
| Shark| 构建在spark上, 是hive的扩展. 目的是不需要mapreduce,在自己的节点上运算| 暂时不成熟| 目前不成熟|
| Apache Phoenix |  基于hbase的搜索引擎 |  |  用了hbase,就可以用它.|&lt;/p&gt;

&lt;h1 id=&quot;hive-3&quot;&gt;HIVE是怎么做的?&lt;/h1&gt;
&lt;p&gt;## 先看具体组件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/56d8760agw1ezc4yts2haj20k50mzdhx.jpg&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;核心是MetaStore组件. 存储hive的元数据, 提供原始meta服务&lt;/p&gt;

&lt;p&gt;具体的运行步骤
&lt;img src=&quot;http://ww4.sinaimg.cn/large/56d8760agw1ezc5jyjjkbj21160j841f.jpg&quot; alt=&quot;此处输入图片的描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;hive-4&quot;&gt;hive主要的数据结构&lt;/h2&gt;

&lt;h3 id=&quot;database&quot;&gt;Database&lt;/h3&gt;
&lt;p&gt;相当于数据库的命名空间&lt;/p&gt;

&lt;h3 id=&quot;table&quot;&gt;table&lt;/h3&gt;
&lt;p&gt;分成两部分数据, 数据文件(存在hdfs里, 在hdfs上, 一个table就是一个文件夹)和元数据(存在关系数据库里)&lt;/p&gt;

&lt;h3 id=&quot;partition&quot;&gt;partition&lt;/h3&gt;
&lt;p&gt;一个partition就是类似于存在一个子目录里.分区列不是表里的某个字段，而是独立的列. 这个字段主要目的是加快分区的查询速度.&lt;/p&gt;

&lt;h3 id=&quot;bucket&quot;&gt;bucket&lt;/h3&gt;
&lt;p&gt;table和partition都是目录级别的拆分数据，bucket则是对数据源数据文件本身来拆分数据。使用桶的表会将源数据文件按一定规律拆分成多个文件，要使用bucket
貌似没啥用&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;参考文献&lt;/h1&gt;
&lt;p&gt;http://www.cnblogs.com/sharpxiajun/archive/2013/06/02/3114180.html&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Oct 2015 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2015/10/01/hive/</link>
        <guid isPermaLink="true">http://gambol.github.io/2015/10/01/hive/</guid>
        
        <category>大数据</category>
        
        
      </item>
    
      <item>
        <title>JDK8 lambda表达式使用</title>
        <description>&lt;h1 id=&quot;jdk-8-lambda&quot;&gt;JDK 8 lambda&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;目的 &amp;amp;&amp;amp; 面向群体&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;介绍回调函数的写法&lt;/p&gt;

&lt;h2 id=&quot;lambda&quot;&gt;lambda存在的原因&lt;/h2&gt;
&lt;p&gt;让程序员更懒&lt;/p&gt;

&lt;h2 id=&quot;lambda-1&quot;&gt;lambda介绍&lt;/h2&gt;
&lt;p&gt;### lambda的组成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(x, y) -&amp;gt; x+y


() -&amp;gt; 42
(String x) -&amp;gt; System.out.println(&quot;i am &quot; + x);

(int k) -&amp;gt; { 
    int x = k * 4; 
    return x;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包括3个部分&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入&lt;/li&gt;
  &lt;li&gt;-&amp;gt;&lt;/li&gt;
  &lt;li&gt;函数体&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;目标对象&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Callable&amp;lt;String&amp;gt; a = () -&amp;gt; &quot;xxx&quot;;
Runnable k = () -&amp;gt; {System.out.println(&quot;xxxx&quot;);}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文所期待的类型进行推导，这个被期待的类型被称为目标类型.条件包括&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;T是一个函数式接口&lt;/li&gt;
  &lt;li&gt;lambda表达式的参数和T的方法参数在数量和类型上一一对应&lt;/li&gt;
  &lt;li&gt;lambda表达式的返回值和T的方法返回值相兼容（Compatible）&lt;/li&gt;
  &lt;li&gt;lambda表达式内所抛出的异常和T的方法throws类型相兼容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;函数式接口&lt;/h3&gt;
&lt;p&gt;看Callable , Runnable的共性。 总结什么是函数式接口
1. 只拥有一个方法
2. 编译器自动判断这个接口是否是函数式接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
interface Teacher {
    void teach();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FunctionalInterface注解不是必须得。（类似于 Override）&lt;/p&gt;

&lt;p&gt;优点: 
可以重用现有的类库
1. java.util.Comparator&lt;/p&gt;

&lt;p&gt;新增一部分常用的类库
1. Predicate&lt;t&gt;——接收T对象并返回boolean
2. Consumer&lt;t&gt;——接收T对象，不返回值
3. Function&amp;lt;T, R&amp;gt;——接收T对象，返回R对象
4. Supplier&lt;t&gt;——提供T对象（例如工厂），不接收值
5. UnaryOperator&lt;t&gt;——接收T对象，返回T对象
6. BinaryOperator&lt;t&gt;——接收两个T对象，返回T对象&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Predicate&amp;lt;String&amp;gt; startsWithK = s -&amp;gt; s.substring(4).startsWith(&quot;k&quot;);

Supplier&amp;lt;Boolean&amp;gt; x = () -&amp;gt; true;

Function&amp;lt;Integer, Integer&amp;gt; tenTimes = (z) -&amp;gt; {
    return z * 10;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点
让现有的类库变复杂了
譬如 Comparator.java&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;默认方法&lt;/h4&gt;
&lt;p&gt;关键字： default&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@FunctionalInterface
interface Teacher {
    void teach();
    
    default boolean ask (String name) {
        System.out.println(name + &quot; 你来回答一下这个问题&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;静态方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  @FunctionalInterface
    interface Teacher {
        void teach();
        
        default boolean ask (String name) {
            System.out.println(name + &quot; 你来回答一下这个问题&quot;);
        }
        
        static void build(List&amp;lt;String&amp;gt; students) {

        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-6&quot;&gt;默认方法的顺序&lt;/h4&gt;
&lt;p&gt;当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface Teacher implements Artist, Doctor { 
    default void work() { 
        Artist.super.work(); 
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;综合实例一&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    List&amp;lt;Person&amp;gt; personList = new ArrayList&amp;lt;&amp;gt;();
    personList.add(new Person(&quot;Virat&quot;, &quot;Kohli&quot;));
    personList.add(new Person(&quot;Arun&quot;, &quot;Kumar&quot;));
    personList.add(new Person(&quot;Rajesh&quot;, &quot;Mohan&quot;));
    personList.add(new Person(&quot;Rahul&quot;, &quot;Dravid&quot;));

    // 在JDK8之前，使用匿名函数解决这个问题
    Collections.sort(personList, new Comparator&amp;lt;Person&amp;gt;() {
        public int compare(Person p1, Person p2) {
            return p1.firstName.compareTo(p2.firstName);
        }
    });

    // JDK8 之后，可以用lambda表达式
    Collections.sort(personList, (Person p1, Person p2) -&amp;gt; p1.firstName.compareTo(p2.firstName));
    
    // 省掉一部分可以由编译器推导出来的类型
    Collections.sort(personList, (p1, p2) -&amp;gt; p1.firstName.compareTo(p2.firstName));

    // 可以用静态方法
    Collections.sort(personList, Comparator.comparing(p -&amp;gt; p.firstName));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;方法引用&lt;/h3&gt;
&lt;p&gt;方法引用也应看作是一个 Lambda 表达式，所以它也需要一个明确的目标类型充当功能性接口的实例。文档里的说法是：避免了 Lambda 写复杂了可读性的问题，也使得逻辑更清晰。&lt;/p&gt;

&lt;p&gt;譬如，上面的语句可以进一步简写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collections.sort(personList, Comparator.comparing(Person::getFirstName));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法引用有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Sep 2015 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2015/09/10/lambda/</link>
        <guid isPermaLink="true">http://gambol.github.io/2015/09/10/lambda/</guid>
        
        <category>JAVA</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>分布式锁的实现</title>
        <description>&lt;p&gt;﻿# 分布式锁&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[toc]&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;分布式锁的作用，说大不大， 说小也不小。 绝大部分时候，应该避免使用分布式锁。 原因是：这个玩意会让系统很复杂，使用起来容易死锁。
然后，确实在高并发的时候，需要用到这个功能。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实现&lt;/h2&gt;

&lt;p&gt;分布式锁的核心是，在一个中心的地方，设置一个字段，说明某个线程正在使用。根据中心的不同，有两个常见选择。 redis 和 zookeeper&lt;/p&gt;

&lt;h3 id=&quot;redis&quot;&gt;基于redis的分布式锁实现&lt;/h3&gt;

&lt;p&gt;目前，已经有基于redis分布式锁的开源实现了。可以参考&lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;redis分布式锁&lt;/a&gt;找到对应语言的开源实现。java对应的开源实现叫redisson。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;单实例&lt;/h4&gt;
&lt;p&gt;如果是单实例的redis的分布式锁实现， 比较容易。步骤大概是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程1 &lt;code&gt;SET lock_name current_timestamp NX PX 30000&lt;/code&gt;  // 设置当前时间为value， 并设置30s的expire时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果插入成功，则获取锁OK。 如果插入失败，则获取锁失败&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码执行完成后，要用一个lua脚本来完成DEL操作。（防止自己超时或者其他原因，删掉了别人持有的锁）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;if redis.call(&quot;get&quot;,lock_name) == current_timestamp then
    return redis.call(&quot;del&quot;,lock_name)
else
    return 0
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;多实例&lt;/h4&gt;
&lt;p&gt;单实例的情况，如果master挂了，则锁就都傻逼了。于是有人提出了多redis实例的方案。&lt;/p&gt;

&lt;p&gt;多实例的方案算法叫Redlock, 原理有点像zk的选举算法. 假设系统里,一共有N个redis实例, 如果想要拿到某一个锁, 必须至少要拿到N/2 + 1 redis实例的锁时,才算成功了.&lt;/p&gt;

&lt;p&gt;算法还有一个精妙的地方是, 考虑了网络的延迟时间, 可以做到即使多个redis实例的系统时间即使不一致,也不会有问题.&lt;/p&gt;

&lt;p&gt;假设一共有5个实例, 客户端获取锁的步骤是:
1. 获取当前时间
2. 用某一个key,轮流请求这5个实例,用随机值(记为X), 用&lt;code&gt;SET lock_name current_timestamp NX PX 30000&lt;/code&gt; 去请求加锁. 如果某一个redis实例挂了,就尽快去请求下一个实例(给这个redis的连接设置一个很短的超时时间). 
3. 客户端会记录5个node总共用到的加锁时间. 如果有3个(以及三个以上)实例设置成功啦,并且加锁时间&amp;lt; 锁的有效时间(这个实例里, 是30S). 则&lt;strong&gt;加锁成功&lt;/strong&gt;. 这个锁的有效期是 30S - 加锁消耗的时间
4. 如果获取锁失败, 则调用上文说的脚本,删除每一个已经加锁成功的redis实例里的锁&lt;/p&gt;

&lt;p&gt;可以参考这个代码: https://github.com/gambol/redis-distributed-lock&lt;/p&gt;

&lt;h3 id=&quot;zookeeper&quot;&gt;基于zookeeper的实现&lt;/h3&gt;
&lt;p&gt;由于zookeeper天生nb的选举算法以及靠谱程度，所以也可以用zookeeper 来做分布式锁。实现方案非常简单。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;前提
在zookeeper中创建一个根节点（Locks），用于后续各个客户端的锁操作
&lt;img src=&quot;http://static.zybuluo.com/gambol/5ugxm42wgdn400vylmujuxwm/640-wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;640-wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1-6.7kB&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取锁的过程
想要获取锁的client都在Locks中创建一个自增序的子节点，每个client得到一个序号，相当于排队
如果自己的序号是最小的，就成功获得锁
如果不是最小的，就关注自己前面的那个序号，发现前面那个走了以后，就轮到自己了
&lt;img src=&quot;http://static.zybuluo.com/gambol/7ai5obf3womgnsi71v9ftdyy/640-wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1%20%281%29&quot; alt=&quot;640-wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1 (1)-14.8kB&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;释放锁的过程
 将自己对应的节点删除即可，下一个排队的节点就可以收到通知，从而被唤醒得到锁
&lt;img src=&quot;http://static.zybuluo.com/gambol/yxojhfj6vgpoe3f0hi4oznjk/640-wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1%20%282%29&quot; alt=&quot;640-wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1 (2)-9.9kB&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;http://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=402727690&amp;amp;idx=1&amp;amp;sn=917f7a3e2023622df766aad58b7b9896#rd&lt;/li&gt;
  &lt;li&gt;http://redis.io/topics/distlock&lt;/li&gt;
  &lt;li&gt;http://blog.jobbole.com/95211/&lt;/li&gt;
  &lt;li&gt;https://github.com/mrniko/redisson/blob/master/src/main/java/org/redisson/RedissonLock.java&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 10 Sep 2015 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2015/09/10/distribution-locker/</link>
        <guid isPermaLink="true">http://gambol.github.io/2015/09/10/distribution-locker/</guid>
        
        <category>分布式</category>
        
        <category>技术</category>
        
        
      </item>
    
  </channel>
</rss>
