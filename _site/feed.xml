<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gambol&#39;s Blog</title>
    <description></description>
    <link>http://gambol.github.io/</link>
    <atom:link href="http://gambol.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 27 Feb 2017 00:24:12 +0800</pubDate>
    <lastBuildDate>Mon, 27 Feb 2017 00:24:12 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>华清嘉园看房笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;华清嘉园看房笔记&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;我一直有学区房的需求. 之前一直看东城/西城的房子, 前些天在smth上看到大家讨论华清嘉园, 于是我去查了一下华清嘉园的价格.  在我记忆中,华清嘉园是一个神盘, 13年时小户型的价格就到了10w左右, 大户型也需要8w.  但是我这次看的时候, 发现华清嘉园的2居室价格在10w-11w左右, 
在这种情况下, 我觉得华清嘉园可能会补涨, 于是我去看了一次房.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;要求&lt;/h2&gt;
&lt;p&gt;我对学区的要求是
- 社区能住人
- 学校不错, 至少中上&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;这次主要看了华清嘉园和东升园, 位置都在五道口附近&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;华清嘉园&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;位置信息: 华清嘉园在五道口地铁站西南边,  离地铁站200米. 
&lt;img src=&quot;http://okrdur7jc.bkt.clouddn.com/17-2-25/67225027-file_1488034857032_c067.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;学校信息: 看上图, 小区里有中关村二小;  小区里有一个启明双语幼儿园, 3900一个月;&lt;/li&gt;
  &lt;li&gt;医院信息: 中关村医院, 海淀医院, 东升医院, 不过貌似都不太好&lt;/li&gt;
  &lt;li&gt;商业信息: 五道口贵为宇宙中心, 商业氛围简直无敌, 什么品牌都有.
华清嘉园里面, 也有非常多的商业, 基本上所有一层都是商业: 小卖部, 洗衣店, 书店, 桌游吧等等.而且, 有些商业就算不在一层,也可能在各个楼层.&lt;/li&gt;
  &lt;li&gt;环境信息: 华清嘉园的物业也是华润集团, 不得不说华润集团做的很好. 即使是这种商业的情况下, 华清嘉园的环境也仍然保持的很好, 并没有太脏, 小区里也比较整洁, 楼也比较新, 楼道里非常干净.&lt;/li&gt;
  &lt;li&gt;车位信息: 楼下固定停车位700一个月, 买的话大概是40w. 外面马路上, 地面上有一些停车位&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;#### 房子信息
具体看的房子包括以下几个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;西南向两居室
这套是北边那一排的一个楼, 但是窗户并不朝街那边开, 所以还算安静
低楼层, 109平, 1200w.  房子采光不好. 今天已经是个大艳阳天了, 但是这个房子基本没有光线.(南边的窗户没有光, 西边的窗户下午才会有光线)
&lt;img src=&quot;http://okrdur7jc.bkt.clouddn.com/17-2-25/58704540-file_1488036396938_1572b.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;双南朝向两居室, 88平 1200w
这是一个在小区里的房子, 比较安静.
lj上没有户型图, 但是我想说,这个房子实在太小了. 我实际上算过华清嘉园的公摊, 得房率大概是75 - 80%之间. 在这种情况下, 88平套内顶多68平,户主家也是有两个小朋友, 这个房子根本就住不了. 另外, 这个价格真的好高.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;150平 3居室
1700w. 相对于前面两个房子, 这套房子简直是好, 户型非常方正, 楼层高, 采光非常好.
&lt;img src=&quot;http://okrdur7jc.bkt.clouddn.com/17-2-25/65781006-file_1488036859169_158a5.png&quot; alt=&quot;&quot; /&gt;.
这套房子满二, 但是原值比较高, 800w左右, 中介说,这个的税费也还可以.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;东升园&lt;/h3&gt;
&lt;p&gt;东升园里, 1,2,3,4 4栋板楼在小区中间, 是回迁楼, 破破烂烂的. 虽然东升园也是2000年左右的房子, 但是物业真是特别烂. 中介小哥说, 东升园自己成立了业委会, 赶走了华润物业, 所以变成了这个样子.
车位只有地上的, 横七竖八画了很多停车位, 个个都上了地锁.&lt;/p&gt;

&lt;p&gt;我看了几个楼, 12号楼和8号楼.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;东向2居, 117平, 1035w
高楼层, 采光不错, 房子的装修也还好. 2梯6户. 户型图如下.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://okrdur7jc.bkt.clouddn.com/17-2-25/65908225-file_1488037284087_cc76.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这套房子单价在9w左右, 我当时很心动,想要回去商量,来买这套房.  但是我根据lj的图, 算了一下得房率, 只有70%. 我和中介小哥确认过, 中介小哥说, 这个面积是LJ实际测量出来的, 如果有差, 也只会差在柜子, 墙上, 不会有太大差别的.  按照这种方法, 我也算了其他几套东升的房子, 得房率都在70-71%左右. 同样的, 按照链家的图来算, 华清嘉园的得房率在75-77%之间. 反正不管怎么说, 东升的公摊大, 这个是不争的事实啦.&lt;/p&gt;

&lt;p&gt;当然, 后来中介小哥告诉我, 下午我回来之后,这套房子就签了. 我祝福他们.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;南北2居, 97.6平, 948w
户型图如下:
&lt;img src=&quot;http://okrdur7jc.bkt.clouddn.com/17-2-25/66663602-file_1488037583350_f7f5.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个一层, 旁边的邻居是一个老奶奶, 过道里放了自行车, 香炉, 盆栽. 看到这种环境, 我怎么都不会买的, 更不用说这个一层暗的一比, 客厅外面是一个天井, 一点光都进不来.  南边的两个房间, 都被挡住了.&lt;/p&gt;

&lt;p&gt;同样,还有一个高层的这个户型, 大小一样, 但是房本上的面积是80平, 报价950w. 
这两个房子, 我都实际算了一下得房率,  (5.8 + 4.9 + 25.3 + 13.6 + 17.6 + 4.2 /2 ) =  69.2 . 69.2 / 97.6  = 71%
这个结果和117平房子的结果是交相辉映的.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;-西南两居, 93.5平, 980w
这个房子的唯一有点是, 楼层高, 能看到唐宁one的豪宅.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://okrdur7jc.bkt.clouddn.com/17-2-25/56632493-file_1488037874856_b96c.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;相比较而言, 华清嘉园比东升园好不少, 贵2w一平,绝对值.&lt;br /&gt;
价格允许的情况下, 我还是倾向于考虑华清嘉园的2居.&lt;/p&gt;

</description>
        <pubDate>Sat, 14 Jan 2017 19:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2017/01/14/huaqing/</link>
        <guid isPermaLink="true">http://gambol.github.io/2017/01/14/huaqing/</guid>
        
        <category>房</category>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>东京城市群的崛起</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;东京城市群的崛起&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;东京简介&lt;/h2&gt;
&lt;p&gt;东京(城市)目前人口约1300w, 行政面积为 2000 平方公里.
东京首都圈: 以东京市区为中心，半径80公里以内，东京都、崎玉县、千叶县、神奈川县共同组成了东京都市圈。东京都市圈总面积1万3千4百平方公里，占全国面积的3.5%；人口约达4000多万人，占全国人口的三分之一以上；GDP占到日本全国的一半.&lt;/p&gt;

&lt;p&gt;对比而言, 北京辖区面积1.68万平方公里，人口2115万人。北京五环以内核心圈，面积667平方公里，人口约1000万人，北京六环内面积2247平方公里，不到30公里的半径内，人口约1477万人。以50公里为半径，面积约8000平方公里，人口约2500万人。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;问题&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;东京是什么背景下开始发展的?&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;时期&lt;/th&gt;
      &lt;th&gt;年代&lt;/th&gt;
      &lt;th&gt;开始时人口数量&lt;/th&gt;
      &lt;th&gt;结束时人口数量&lt;/th&gt;
      &lt;th&gt;人口增长比例&lt;/th&gt;
      &lt;th&gt;主要的时代特征&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;明治时代&lt;/td&gt;
      &lt;td&gt;1905-&amp;gt;1925&lt;/td&gt;
      &lt;td&gt;2.5M&lt;/td&gt;
      &lt;td&gt;4.5M&lt;/td&gt;
      &lt;td&gt;80%&lt;/td&gt;
      &lt;td&gt;明治维新,日本开始发展.&lt;/td&gt;
      &lt;td&gt;东京中心城出现了学徒,小买卖的雇佣需求. 增加了就业机会,也促进了农村劳动力的发展&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;大正,昭和&lt;/td&gt;
      &lt;td&gt;1925-&amp;gt;1947&lt;/td&gt;
      &lt;td&gt;4.5M&lt;/td&gt;
      &lt;td&gt;5M&lt;/td&gt;
      &lt;td&gt;10%&lt;/td&gt;
      &lt;td&gt;一战, 二战&lt;/td&gt;
      &lt;td&gt;由于战争的关系, 东京人口出现外迁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;二战后复兴&lt;/td&gt;
      &lt;td&gt;1947-&amp;gt;1965&lt;/td&gt;
      &lt;td&gt;5M&lt;/td&gt;
      &lt;td&gt;11M&lt;/td&gt;
      &lt;td&gt;120%&lt;/td&gt;
      &lt;td&gt;日本二战后复兴.&lt;/td&gt;
      &lt;td&gt;首先(到1955年)是战争期间疏散的人群, 重新聚集回市中心. 1955年后, 市中心的聚集速度减慢, 主要向周边10-30公里的郊区聚集&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;高速发展期&lt;/td&gt;
      &lt;td&gt;1965-&amp;gt;1985&lt;/td&gt;
      &lt;td&gt;11M&lt;/td&gt;
      &lt;td&gt;12M&lt;/td&gt;
      &lt;td&gt;10%&lt;/td&gt;
      &lt;td&gt;日本经济的黄金发展期&lt;/td&gt;
      &lt;td&gt;中心城区人口减少, 周边30-50公里的郊区人口快速增长&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;泡沫期&lt;/td&gt;
      &lt;td&gt;1985-&amp;gt;2000&lt;/td&gt;
      &lt;td&gt;12M&lt;/td&gt;
      &lt;td&gt;12M&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;经济出现泡沫&lt;/td&gt;
      &lt;td&gt;刺破泡沫后, 东京的人口也没有显著的增长&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;经济复苏&lt;/td&gt;
      &lt;td&gt;2000 -&amp;gt;2010&lt;/td&gt;
      &lt;td&gt;12M&lt;/td&gt;
      &lt;td&gt;13M&lt;/td&gt;
      &lt;td&gt;8%&lt;/td&gt;
      &lt;td&gt;经济出现复苏迹象&lt;/td&gt;
      &lt;td&gt;中心人口重现增长. 主要原因是中心房价降低, 住宅供应量大量增加&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;两次大的增长为:
1. 明治时代. (1905 -&amp;gt; 1925) 人口从250w增长到450w.
2. 二战重建 (1947-&amp;gt;1965) 人口从500w增长到1100w.&lt;/p&gt;

&lt;p&gt;这两次大的增长的特诊都基本相同: 城市发展, 需要年轻的劳动人口.
另外,东京在这段期间, 都建造了许多的铁路, 也促进了人口的涌入.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;东京如何从一个大型城市, 发展成了一个巨大型的都市圈?&lt;/h3&gt;
&lt;p&gt;东京在人口集聚的过程中,由于经济发展水平落后，城市公共服务供给能力严重不足，低收入和贫困人口的大量涌入，导致城市贫困问题十分突出，环境和公共卫生条件恶化，住房短缺等城市病大量出现。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;政策方面&lt;/h4&gt;
&lt;p&gt;1958年时, 日本中央政府制定了针对东京都市圈发展的地方性规划&lt;首都圈整备计划&gt;, 该计划限制建成区的蔓延时开发和在生活基础设备落后情况下的人口和产业聚集.&lt;/首都圈整备计划&gt;&lt;/p&gt;

&lt;p&gt;在此之后,日本先后4次重新规划了周边新城的&lt;首都圈规划建设&gt;,&lt;/首都圈规划建设&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;次数&lt;/th&gt;
      &lt;th&gt;时间&lt;/th&gt;
      &lt;th&gt;背景&lt;/th&gt;
      &lt;th&gt;范围&lt;/th&gt;
      &lt;th&gt;方针&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1958&lt;/td&gt;
      &lt;td&gt;东京人口过于集中&lt;/td&gt;
      &lt;td&gt;东京周边100公里&lt;/td&gt;
      &lt;td&gt;建设城市绿带, 新的城市建设要以东京卫星城或工业城市的形式开发, 满足吸收人口的需求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1968&lt;/td&gt;
      &lt;td&gt;社会环境发生改变, 影响了第一次的计划&lt;/td&gt;
      &lt;td&gt;东京, 千叶,神奈川等8县&lt;/td&gt;
      &lt;td&gt;加强周围卫星城市的规划, 设定周边50公里范围为近郊建设区域(不再使用绿带这个名词)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1976&lt;/td&gt;
      &lt;td&gt;石油危机&lt;/td&gt;
      &lt;td&gt;东京周边8县&lt;/td&gt;
      &lt;td&gt;促进周边城市的商务,教育和文化功能的建设, 使周边城市成为一个独立的大都市&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1986&lt;/td&gt;
      &lt;td&gt;信息化, 高龄化&lt;/td&gt;
      &lt;td&gt;周边8县&lt;/td&gt;
      &lt;td&gt;强化中心区的国际金融职能 和 管理职能.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1999&lt;/td&gt;
      &lt;td&gt;首都圈金融成熟阶段&lt;/td&gt;
      &lt;td&gt;周边8县&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;目前, 东京都市圈的主要分工为
&lt;img src=&quot;http://img3.jiemian.com/jiemian/original/20161115/147917462293205600_a580xH.jpg&quot; alt=&quot;东京都市圈分工&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;实际阶段&lt;/h4&gt;
&lt;p&gt;日本的都市圈形成过程中, 主要分成以下几个阶段&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;时间&lt;/th&gt;
      &lt;th&gt;背景&lt;/th&gt;
      &lt;th&gt;人口变化&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;城市化(1955-1965)&lt;/td&gt;
      &lt;td&gt;东京,名古屋等,利用港口优势, 发展制造业.&lt;/td&gt;
      &lt;td&gt;与工业化伴随的年轻劳动力、尤其是蓝领工人流入, 中心人口城市发展.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;第一次郊区化(1965-1985).&lt;/td&gt;
      &lt;td&gt;工厂迁向郊区, 中心城市的流通和管理功能发展，白领人口增加&lt;/td&gt;
      &lt;td&gt;新流入的人口在郊区寻找住所, 中心城区租房子的年轻家庭,为养育孩子而迁移至郊区&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;第二次郊区化 (1985-2000)&lt;/td&gt;
      &lt;td&gt;泡沫经济, 地价高涨.城市中心区域再开发&lt;/td&gt;
      &lt;td&gt;原来住在中心城市的人,也向郊区迁移&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;再城市化 (2000-至今)&lt;/td&gt;
      &lt;td&gt;地价下降,中心区住宅增加&lt;/td&gt;
      &lt;td&gt;人群重新回到市中心&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;总结如下, 都市圈的形成分成3个期
1. 人口激增期。一般为城市化初期，人口从周边地域流向中心城市，使中心城市人口猛增。
2. 人口增长减缓期，一般为城市郊区化时期。由于工业转移和城市扩展，中心城区地价上涨，使人口从中心城区向城市边缘区迁移。
3.  人口增长再回归期，相对应的是城市再开发期。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;发展过程中, 主要遇到了哪些问题? 如何解决的?&lt;/h3&gt;

&lt;h4 id=&quot;section-8&quot;&gt;交通问题&lt;/h4&gt;
&lt;p&gt;1980s时, 东京的主要交通方式是自用车出行. 造成了一系列的问题(环境, 拥堵等等). 为了解决这个问题, 东京主要做了几件事情
1.  提升公共交通服务质量. 票价优惠
2.  改善末段交通, 鼓励自行车为主的近距离出行(ofo正在做的事情?)
3.  围绕车站进行商业中心建设, 在地铁站周围建设有生活功能的住宅区
4.  限行机动车辆. (征收更高的税费, 市中心高停车费)
5.  补贴公交建设&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;城市容积率问题&lt;/h4&gt;
&lt;p&gt;政府控制每个区域的容积率&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;老龄化的过程中, 东京做了哪些事情?&lt;/h3&gt;
&lt;p&gt;暂时跳过&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;我的思考&lt;/h2&gt;

&lt;h3 id=&quot;section-12&quot;&gt;北京需要类似于东京都市圈吗?&lt;/h3&gt;
&lt;p&gt;必然需要.&lt;/p&gt;

&lt;p&gt;一方面, 政策层面.
1958年日本政府的&lt;首都圈规划建设&gt;的同时, 日本在1960年时,也提出过副中心建设的策略. 与此相对应的, 中国政府也与2015年左右, 提出了京津冀一体化与通州副中心建设.
二者的时代背景和方针非常类似.
第二方面, 经济层面.
巨大城市的出现, 是符合经济发展的特征. 资源依赖于人口, 反过来,人也会向资源聚集.  工业化路径使得产业多集中在大城市以发挥城市的规模效益。当城市形成巨大的规模效益时，会持续产生虹吸效应.&lt;/首都圈规划建设&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;北京目前处于哪个阶段?&lt;/h3&gt;
&lt;p&gt;如果按照都市圈的3个阶段划分(人口激增期, 增长减缓期, 增长再回归期), 我觉得北京属于 激增期的末期. 原因有几个
1. 政府明确控制北京人口的增长. 整治服务业人群
2. 郊区化初现端倪. 房山, 燕郊聚集的人口越来越多&lt;/p&gt;

&lt;p&gt;然而, 如果真是京津冀一体化, 现在河北的城镇化水平太低, 人口预计短期还是会涌入北京.&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;郊区化的过程中, 哪些城市有机会&lt;/h3&gt;
&lt;p&gt;结合东京的发展过程, 一个靠谱的新城, 至少有以下要求
1. 离北京近. 东京辐射的区域大概是 30-50km. (大概说一个概念, 如果假设五环为东京的中心区, 南五环到天津的距离约是130km, 北京到通州距离10km, 东五环到燕郊25km)
2. 适宜的房价. (多少算低? )
3. 交通便宜&amp;amp;便捷. 从东京的发展来看, 新城的建设主要是围绕低价的城际轨道交通展开的. (注意,不是高铁和高速, 因为高铁和高速价格较高). 30公里大概是城郊轨道一个小时的时间.
4. 舒适的居住体验, 以及相对较完整的配套设施.&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;在这个过程中, 还有哪些行业会有机会?&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;基础设施行业. (大量新城的崛起, 需要配套的基础设施)&lt;/li&gt;
  &lt;li&gt;交通&lt;/li&gt;
  &lt;li&gt;从北京往外迁的行业&lt;/li&gt;
  &lt;li&gt;房地产投资 (如果能在政策刚出来时, 敏锐的抓住新城的建设机会, 相信会有较高的回报率)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-16&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://item.jd.com/1750867996.html&quot;&gt;机遇与谋划&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://star.news.sohu.com/20161106/n472410757.shtml&quot;&gt;梁建章 : 控制人口规模不是好事&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%9C%E4%BA%AC&quot;&gt;wiki 东京&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jiemian.com/article/958563.html&quot;&gt;都市圈的形成&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ccud.org.cn/2014-07-11/114328859.html&quot;&gt;还有多远&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 04 Dec 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/12/04/tokyo/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/12/04/tokyo/</guid>
        
        <category>人口</category>
        
        <category>政策</category>
        
        
      </item>
    
      <item>
        <title>黄金投资,买什么</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在ABX 13块钱, 黄金价格大概是$1200 的时候, 我写了一个笔记, 说应该中长期看好黄金. 现在ABX已经到了$23, 黄金价格到了1335, 我突然醒悟过来, 现在也需要配置一部分黄金用来投资 &amp;amp; 避险.&lt;/p&gt;

&lt;p&gt;至于为什么要买黄金, 前面有笔记说了. 简单的来说, 逻辑是
1. 货币超发严重
2. 避险情绪强烈
3. 黄金被低估&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;黄金投资的种类&lt;/h2&gt;

&lt;p&gt;我适合投资的资产, 在美股里, 所以我主要考虑的是美股etf和金矿相关的美股.   实物金条之类的, 太不方便保存了, 不考虑.&lt;/p&gt;

&lt;h3 id=&quot;etf&quot;&gt;ETF&lt;/h3&gt;

&lt;h4 id=&quot;gld&quot;&gt;GLD&lt;/h4&gt;
&lt;p&gt;GLD，全名SPDR GOLD TRUST。它是全世界最大的黄金ETF，它的持仓变动甚至会影响黄金短期价格走势，杠杆炒金的人会拿它做交易参考。&lt;/p&gt;

&lt;p&gt;这个GLD的优势是，它是真实持有实物黄金的，它现在有881.15吨黄金存在汇丰银行银行在伦敦的金库里，对应的总价值是35,154,496,611.55美元，除以总份额2.966亿，就是它现在的价格118.82左右。也就是说，你买了它的基金份额，背后是有实物黄金做背书的。GLD和黄金价格完全挂钩, 也就是说, 黄金从1090 涨到1330 的过程中, GLD也刚好涨了30%.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/h0va9cufiaygir88avd5ygwn/image_1anapj9e0ujm74il3d75i5tm9.png&quot; alt=&quot;GLD&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GLD每年的费用是 0.4%. 还算便宜.&lt;/p&gt;

&lt;h4 id=&quot;gdx&quot;&gt;GDX&lt;/h4&gt;

&lt;p&gt;GDX做多金矿指数，该ETF追踪标的为纽交所和纳斯达克上市的全球黄金矿业公司的市值加权指数，具体可查看指数： NYSE Arca Gold Miners Index（GDM），标的成分是全球“大型”的金银矿公司，包括Gold corp (GG)、纽曼矿业(NEM)、巴里克黄金公司(ABX)等。这个指数具体可以查看这里：https://www.nyse.com/quote/index/GDM，该ETF是单倍做多&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/slll2pbzv41jbsaxu5t2l1vd/image_1anapkafb1o13ik7t0q4td1oi6m.png&quot; alt=&quot;GDX&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GDX的管理费用是 0.52%&lt;/p&gt;

&lt;h4 id=&quot;nugt&quot;&gt;NUGT&lt;/h4&gt;
&lt;p&gt;这是一个三倍做多黄金的股票, 他追踪的指数和 GDX相同, 只不过带了3倍杠杆. 管理费用是每年1.03 %&lt;/p&gt;

&lt;p&gt;不过我不喜欢这种带杠杆的ETF. 不容易控制风险.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;金矿相关股票&lt;/h3&gt;
&lt;p&gt;金矿相关的股票有几个需要关注的&lt;/p&gt;

&lt;h4 id=&quot;pglc&quot;&gt;PGLC&lt;/h4&gt;
&lt;p&gt;PGLC手头收购了大量的已探明矿产, 但是他就是不开采, 要等金价更高之后,再进行开采. 所以, PGLC最近的价格涨得相对较少.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/6eg5o5n7ertnqlonqcj7jkbg/image_1anaps37g9q3m7kggj1bl21bhm13.png&quot; alt=&quot;PGLC&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PGLC的优势是, 他还没有发力, 缺点是, 市值太少, 成交量太低, 将来不好出手.&lt;/p&gt;

&lt;h4 id=&quot;abx&quot;&gt;ABX&lt;/h4&gt;
&lt;p&gt;13块钱的时候, 就有人告诉我这是一个好票. ABX做的事情是黄金加工,公司把黄金从开采出来的矿石里提炼出来，然后加工、融化成液体、浇筑成形、并运输。
这个公司是全世界最大的黄金生产商，2015年产量高达600万盎司。在美国、加拿大、秘鲁、阿根廷、澳大利亚、多米尼加等地都有矿产。 有9200万盎司黄金矿储，浓度级别大概是0.04盎司/吨，是行业里矿储最多的了。
它的董事会执行主席是高盛的前总裁John Thornton，而且高盛的前董事会副主席Michael Evans现在也在这家公司。&lt;/p&gt;

&lt;p&gt;真是因为这个原因, ABX在最近这波热潮中,涨了3倍.&lt;/p&gt;

&lt;p&gt;![ABX走势][http://static.zybuluo.com/gambol/wwmq1o3bytfiuwx01gqoa981/image_1anaq25m11fe38fv1k1k1vgvao61g.png]&lt;/p&gt;

&lt;h4 id=&quot;fnv&quot;&gt;FNV&lt;/h4&gt;
&lt;p&gt;FNV做的事情, 类似于金矿股的风投.FNV会在其他公司开采黄金之前，为它们提供资金，从而换取它们未来黄金开采量的一部分所有权。这种模式的好处是，它能享受黄金价格上涨的所有好处，但却不需要承担开采公司所需的一切开支和风险。&lt;/p&gt;

&lt;p&gt;这家公司在全世界有383处资产，其中262处都是黄金白银的“版权矿”资产。再其中的46个项目此时此刻正在开采，也就是正在产出收益。另外有40个项目正在去往开采的路上&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/9u6yf9n289ipqpigbfz87vkx/image_1anaq71pvb83mkq5ke17fg1ie21t.png&quot; alt=&quot;FNV介绍&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;综合看下来, 我倾向于GLD(低风险, 低收益)和ABX(优质公司, 风险较大)&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODU2MTA2OQ==&amp;amp;mid=502176277&amp;amp;idx=1&amp;amp;sn=0d113e4713df880c8c942c84a7708210&amp;amp;scene=1&amp;amp;srcid=0710Ditu9QwSn7dQpGzigmnU&amp;amp;key=77421cf58af4a6537e9f6f96d0090845b667b3d787fbf8a0c5d0076524c2856373d6c4717287cf7fbc92d5a716a94a2c&amp;amp;ascene=0&amp;amp;uin=NzExMDU2NTIw&amp;amp;devicetype=iMac14,1%20OSX%20OSX%2010.11.5%20build%2815F34%29&amp;amp;version=11020201&amp;amp;pass_ticket=TzvFGKn0xUlHEMgVrmRHpNYSpisgPsPNppXu3hbIl5255gpsDZwznAZgdOGVNWNj&quot;&gt;全网最权威的黄金指南&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODU2MTA2OQ==&amp;amp;mid=502176284&amp;amp;idx=1&amp;amp;sn=3db694c6e69708f5fc761021281a9149&amp;amp;scene=20&amp;amp;key=77421cf58af4a6538cc5b9c9613769e5c94bfc42147a55a501469873d39bdac0a778e5fa48869aedd073a770a478b2dc&amp;amp;ascene=0&amp;amp;uin=NzExMDU2NTIw&amp;amp;devicetype=iMac14%2C1+OSX+OSX+10.11.5+build(15F34)&amp;amp;version=11020201&amp;amp;pass_ticket=TzvFGKn0xUlHEMgVrmRHpNYSpisgPsPNppXu3hbIl5255gpsDZwznAZgdOGVNWNj&quot;&gt;FNV介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xueqiu.com/4857977486/69151081&quot;&gt;金矿ETF介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 10 Jul 2016 08:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/07/10/gold/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/07/10/gold/</guid>
        
        <category>投资</category>
        
        
      </item>
    
      <item>
        <title>Spring &quot;no matching editors or conversion strategy found&quot;的问题解决 以及 Spring AOP代理的介绍</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;昨天晚上,在线上调试时, 发现在一个spring的bean里, 只要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt;注解后, 就会在spring启动时报错&lt;/p&gt;

&lt;p&gt;报错信息有点多, 需要注意的点只有一点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cannot convert value of type [com.sun.proxy.$Proxy21 implementing gambol.examples.spring.service.Console,org.springframework.aop.SpringProxy,org.springframework.aop.framework.Advised] to required type [gambol.examples.spring.service.AbstractConsole] for property &#39;abstractConsole&#39;: no matching editors or conversion strategy found
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;先说解决方案, 增加一行配置, 解决&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;强制使用cglib进行代理.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;解决过程&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;早上看完报错信息之后, liuyue猜测是因为使用了transactional之后, 生成的是jdk的proxy, jdk的proxy不能注入成AbstractConsole.&lt;/li&gt;
  &lt;li&gt;我有疑问, 为什么使用了transactional注解之后才生成代理? 难道不是所有spring管理的service都会生成一个代理么?&lt;/li&gt;
  &lt;li&gt;我把线上的代码层次拷贝到了本地,生成的代码结构是&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/gambol/dmis2hbypu7g0o9yqm70dbkr/image_1alrm8q5j16mtp0510m143io7l9.png&quot; alt=&quot;image_1alrm8q5j16mtp0510m143io7l9.png-32.3kB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, consoleService会通过spring 注入到contanerService里.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;bean id=&quot;containerService&quot; class=&quot;gambol.examples.spring.service.ContainerService&quot;&amp;gt;
    &amp;lt;property name=&quot;abstractConsole&quot; ref=&quot;consoleService&quot;/&amp;gt;
  &amp;lt;/bean&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ConsoleService的代码是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service
public class ConsoleService extends AbstractConsole {

    @Transactional
    public void test() {
        System.out.println(&quot; test in consoleService&quot;);
       // console();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在本地启动, 问题无法重现. debug时发现, 当去掉&lt;code class=&quot;highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt;注解后, ConsoleService并没有生成任何代理. 加上&lt;code class=&quot;highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt;注解后, ConsoleService使用CGLib生成代理.&lt;/li&gt;
  &lt;li&gt;突然发现, 我的Console这个接口里并没有任何方法, 在Console加上方法, 再重启tomcat, 问题复现.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Console {
    // 这个方法很关键
    void console();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;到现在为止, 线上问题的原因已经确认. &lt;strong&gt;jdk的proxy不能注入成AbstractConsole.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;解决方案是:   强制使用CGlib来生成代理.(Spring官方的说法是, JDK生成的代理, 比cglib的代理稍微快一点, 所以会默认使用jdk生成的基于接口的代理)&lt;/li&gt;
  &lt;li&gt;引入了一个新的问题: 为什么Console里没有方法时, spring就会使用cglib进行代理, spring是怎么判断的?&lt;/li&gt;
  &lt;li&gt;debug spring的启动过程, 最后在&lt;code class=&quot;highlighter-rouge&quot;&gt;ProxyProcessorSupport.java&lt;/code&gt;里找到原因.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  protected void evaluateProxyInterfaces(Class&amp;lt;?&amp;gt; beanClass, ProxyFactory proxyFactory) {
    Class&amp;lt;?&amp;gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader());
    boolean hasReasonableProxyInterface = false;
    for (Class&amp;lt;?&amp;gt; ifc : targetInterfaces) {
      if (!isConfigurationCallbackInterface(ifc) &amp;amp;&amp;amp; !isInternalLanguageInterface(ifc) &amp;amp;&amp;amp;
      // Spring会在这段代码里, 判断需要代理的接口里的方法数量
          ifc.getMethods().length &amp;gt; 0) {
        hasReasonableProxyInterface = true;
        break;
      }
    }
    if (hasReasonableProxyInterface) {
      // Must allow for introductions; can&#39;t just set interfaces to the target&#39;s interfaces only.
      for (Class&amp;lt;?&amp;gt; ifc : targetInterfaces) {
        proxyFactory.addInterface(ifc);
      }
    }
    else {
      proxyFactory.setProxyTargetClass(true);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结论/收获&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;spring并不会为每个bean,都生成代理类&lt;/li&gt;
  &lt;li&gt;只有使用AOP时, spring才会为他生成代理类(proxy class)&lt;/li&gt;
  &lt;li&gt;生成代理类的规则&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方式&lt;/th&gt;
      &lt;th&gt;proxy-target-class=”false”(默认情况)&lt;/th&gt;
      &lt;th&gt;proxy-target-class=”true”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;bean实现了一个非空接口&lt;/td&gt;
      &lt;td&gt;使用JDK proxy 生成接口的代理&lt;/td&gt;
      &lt;td&gt;CGLIB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bean未实现一个非空接口&lt;/td&gt;
      &lt;td&gt;CGLIB代理生成实体bean&lt;/td&gt;
      &lt;td&gt;CGLIB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://cliffmeyers.com/blog/2006/12/29/spring-aop-cglib-or-jdk-dynamic-proxies.html&quot;&gt;Spring AOP: CGLIB or JDK Dynamic Proxies?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop-api.html#aop-pfb-proxy-types&quot;&gt;Spring官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 20 Jun 2016 08:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/06/20/spring-no-app/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/06/20/spring-no-app/</guid>
        
        <category>JAVA</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>IB账户信息介绍</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;起因&lt;/h2&gt;

&lt;p&gt;ib的个人账户信息实在太复杂了, 一直都迷迷糊糊的. 这次认真学习一下&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;看图说话&lt;/h2&gt;

&lt;p&gt;这是我的账户截图
&lt;img src=&quot;http://static.zybuluo.com/gambol/cbzln0w2zds2wsf8jx0ounpc/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-06-10%20%E4%B8%8B%E5%8D%889.35.55.png&quot; alt=&quot;账户图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体解释请看下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;行&lt;/th&gt;
      &lt;th&gt;中文翻译&lt;/th&gt;
      &lt;th&gt;计算公式&lt;/th&gt;
      &lt;th&gt;注释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Net liquidation Value&lt;/td&gt;
      &lt;td&gt;净清算值&lt;/td&gt;
      &lt;td&gt;总现金值+股票值+证券期权值+债 券值+基金值&lt;/td&gt;
      &lt;td&gt;账户的总价值 . 等于你的证券总价值 + 现金额&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Equity with Load Value&lt;/td&gt;
      &lt;td&gt;含借贷值股权&lt;/td&gt;
      &lt;td&gt;现金账户: 结算的现金。 保证金账户: 全部现金值+股票值+ 债券值+基金值+欧洲&amp;amp;亚洲期权 值。&lt;/td&gt;
      &lt;td&gt;一直以为, 这个值和 net liquidation value是相同的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Current initial Margin&lt;/td&gt;
      &lt;td&gt;当前初始保证金&lt;/td&gt;
      &lt;td&gt;所有股票的初始保证金之和&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Current Maintenance Margin&lt;/td&gt;
      &lt;td&gt;当前维持保证金&lt;/td&gt;
      &lt;td&gt;维持这个比例, 你所需要的最低保证金数量&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Current Available Funds&lt;/td&gt;
      &lt;td&gt;当前可用金额&lt;/td&gt;
      &lt;td&gt;含借贷值股权-初始保证金&lt;/td&gt;
      &lt;td&gt;这个值,就是你可以提现的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Current Excess Liquidity&lt;/td&gt;
      &lt;td&gt;当前剩余流动性&lt;/td&gt;
      &lt;td&gt;含贷款值股权-维持保证金&lt;/td&gt;
      &lt;td&gt;剩余流动性是整个表里最重要的指标. 剩余流动性小于0时, IB会平仓你的部分头寸. 买入股票,或者股价下跌, 剩余流动性都会减少&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Buying power&lt;/td&gt;
      &lt;td&gt;购买力&lt;/td&gt;
      &lt;td&gt;现金账户: 净清算值 -初始保证金.  标准保证金账户:(净清算值 -初始保证金) * (杠杆倍数, 通常为4)&lt;/td&gt;
      &lt;td&gt;这个值告诉你,你还有多少钱可以操作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-2&quot;&gt;进一步说明结算公式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;保证金要求. 保证金要求 = 证券总价值 * 0.25.  但是对于reg t margin账户来说, 有一部分股票要求的是100%的保证金, 譬如ctrp. 这些股票的列表请看&lt;a href=&quot;https://www.ibkr.com.cn/en/index.php?key=&amp;amp;cntry=usa&amp;amp;tag=United+States&amp;amp;ib_entity=hk&amp;amp;ln=&amp;amp;f=5168&amp;amp;ns=T&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;触发自动平仓的计算公式.  股票的亏损值 = （总资产-保证金要求）/（1-保证金比例）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;举例说明&lt;/h2&gt;

&lt;p&gt;假设, 自有资金10000美金，买入baba200股，股价100美金，初始保证金比例25%。（启动2倍杠杆）&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ol&gt;
    &lt;li&gt;证券总价值：100*200=20000美金&lt;/li&gt;
    &lt;li&gt;现金额=-10000美金&lt;/li&gt;
    &lt;li&gt;总资产=证券总价值+现金额=20000-10000 =10000美金&lt;/li&gt;
    &lt;li&gt;保证金要求=20000*25%=5000&lt;/li&gt;
    &lt;li&gt;购买力=（10000-5000）*4=20000&lt;/li&gt;
    &lt;li&gt;日内风控值=总资产-保证金要求=10000-5000=5000&lt;/li&gt;
    &lt;li&gt;触发平仓的亏损额=总资产-保证金要求/1-25% =10000-5000/1-25%=6666&lt;/li&gt;
    &lt;li&gt;6666美金/200股=33.33，则股价下跌33.33（股价为66.67）时被强制平仓&lt;/li&gt;
  &lt;/ol&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.interactivebrokers.com/en/software/tws/usersguidebook/realtimeactivitymonitoring/available_for_trading.htm#XREF_98990_Available_for&quot;&gt;IB官方说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_48fa17ad0102xjtq.html&quot;&gt;sina博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xueqiu.com/4586203773/30860827&quot;&gt;IB账户介绍–from 雪球&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 10 Jun 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/06/10/ib-account/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/06/10/ib-account/</guid>
        
        <category>IB</category>
        
        <category>经济</category>
        
        
      </item>
    
      <item>
        <title>如何写代码</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;起因&lt;/h2&gt;

&lt;p&gt;本来是要做一个ppt介绍的. 写了ppt, 放在博客上做个纪念吧.&lt;/p&gt;

&lt;p&gt;请 &lt;a href=&quot;http://gambol.github.io/download/write_code.pdf&quot;&gt;下载 PDF&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/06/09/write-code/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/06/09/write-code/</guid>
        
        <category>代码</category>
        
        <category>JAVA</category>
        
        
      </item>
    
      <item>
        <title>如何做好架构</title>
        <description>&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;写在前面的话&lt;/h2&gt;
&lt;p&gt;记录看到不错的架构文章.加上自己的思考. 不定期更新.
现在包含了两篇文章&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20005177&quot;&gt;软件设计杂谈&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2014/11/sacrificial-architecture&quot;&gt;Martin Fowler阐述“牺牲的架构”&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;软件设计杂谈&lt;/h2&gt;

&lt;p&gt;url:   https://zhuanlan.zhihu.com/p/20005177
这篇文章很赞, 里面的许多观点我非常赞同.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;前提&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;搞懂需求. 分析需求, 弄清楚需求的底层原因和想要解决的问题&lt;/li&gt;
  &lt;li&gt;设计多个解决方案
    &lt;ul&gt;
      &lt;li&gt;外包&lt;/li&gt;
      &lt;li&gt;利用开源系统&lt;/li&gt;
      &lt;li&gt;自己重写
选择一个适合自己的方案.
&lt;em&gt;工程师现在越来越贵，能用合理的价格搞定的功能，就不该雇人去打理（自己打脸）。一个产品，最核心的部分不超过整个系统的20%，把人力资源铺在核心的部分，才是软件设计之道。&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;软件设计&lt;/h3&gt;

&lt;p&gt;一. 分解问题&lt;/p&gt;

&lt;p&gt;软件设计是一个把大的问题不断分解，直至原子级的小问题，然后再不断组合的过程.  分解和组合在软件设计中的作用如此重要，以至于一个系统如果合理分解，那么日后维护的代价就要小得多。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: 这里所说的分解, 不一定是分解系统, 而是分解问题. 把问题分成有机的小问题(小模块), 然后再将小模块细分.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;分解的太细, 给自己的维护带来麻烦. 不做分解, 将来不好扩展.
一个比较好方法是: 不要考虑太远, 考虑半年. 如果你觉得半年之内,  可能需要改动, 就预留出扩展.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;二 . 总线&lt;/p&gt;

&lt;p&gt;定义系统的整个总线(框架). 
&lt;em&gt;总线把生产者和消费者分离，让彼此互不依赖。心脏往外供血时，把血压入动脉血管就是了。它并不需要知道谁是接收者。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在web项目里, spring通常是这个大的总线. 分拆到各个小模块里, 总线可能是一个 责任链, 或者某个消息队列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;三.路由&lt;/p&gt;

&lt;p&gt;路由包括外部路由和内部路由
&lt;em&gt;外部路由处理输入，把不同的输入dispatch到系统里不同的组件。做web app的，可能没有意识到，但其实每个web framework，最关键的组件之一就是url dispatch。&lt;/em&gt;
&lt;em&gt;内部路由则需工程师考虑。service级别的路由（数据流由哪个service处理）可以用consul等service discovery组件，service内部的路由（数据流到达后怎么处理）则需要自己完成。路由的具体方式有很多种，pattern matching最为常见。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;看懂了他文字, 手上没有特别好的例子来解释. — 我也没有弄明白他说的真实含义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;四. 队列&lt;/p&gt;

&lt;p&gt;&lt;em&gt;仔细想想，队列其实就是总线+路由（可选）+存储的一个特殊版本。一般而言，system bus之上是系统的各个service，每个service再用service bus（或者queue）把micro service chain起来，然后每个micro service内部的组件间，再用queue连接起来。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补充说明: 消息机制. 消息机制也是一个很好的解耦方案. 缺点是: 让系统复杂性变高. 在合适的地方用消息. 
消息驱动看上去很美, 对开发同学要求比较高.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;五. 协议(protocol)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;一旦我们把系统分解成一个个service，service再分解成micro service，彼此之间互不依赖，仅仅通过总线或者队列来通讯，那么，我们就需要协议来定义彼此的行为。协议听起来很高大上，其实不然。我们写下的每个function（或者每个class），其实就是在定义一个不成文的协议：function的arity是什么，接受什么参数，返回什么结果。调用者需严格按照协议调用方能得到正确的结果。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;六. 代谢&lt;/p&gt;

&lt;p&gt;&lt;em&gt;软件系统也是如此。日志会把硬盘写满，软件会失常，硬件会失效，网络会拥塞等等。一个好的软件系统需要一个好的代谢系统：出现异常的服务会被关闭，同样的服务会被重新启动，恢复运行。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;时刻关注系统, 最好能未雨绸缪,发现系统的瓶颈. 不停的解决系统目前的短板. 这个短板可能是性能短板, 也可能是开发效率上的短板&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;七. 高可用&lt;/p&gt;

&lt;p&gt;&lt;em&gt;大部分软件系统里的各种服务也需要高可用性：除非完全无状态的服务，且服务重启时间在ms级。服务的高可用性和路由是息息相关的：高可用性往往意味着同一服务的冗余，同时也意味着负载分担。好的路由系统（如consul）能够对路由至同一服务的数据在多个冗余服务间进行负载分担，同时在检测出某个失效服务后，将数据路只由至正常运作的服务。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高可用性还意味着非关键服务，即便不可恢复，也只会导致系统降级，而不会让整个系统无法访问。就像壁虎的尾巴断了不妨碍壁虎逃命，人摔伤了手臂还能吃饭一样，一个软件系统里统计模块的异常不该让用户无法访问他的个人页面。*&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;说了两件事情: 1. 任何service, 都至少有两台机器组成集群
2. 有办法及时关闭不可用的servce, 保证整个系统的主要业务正常
通常在实现时, 有几种解决方法: a. 给业务增加开关. b.减少进来的用户, 把压力反馈在源头&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;八. 安全性&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在业务较小时, 开发效率比安全重要. 业务有一定规模时, 安全比开发效率重要&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;九. 落实你的设计&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在进入开发之前, 将设计方案概括出来, 写在纸上, 并且和人说清楚.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;十. 谦虚 &amp;amp;&amp;amp; 接受别人的意见&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设计错了没有关系, 反思并改正.
when the facts change, I change my mind.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;martin-fowler&quot;&gt;Martin Fowler阐述“牺牲的架构”&lt;/h2&gt;
&lt;p&gt;第二篇文章,  url地址是: http://www.infoq.com/cn/news/2014/11/sacrificial-architecture&lt;/p&gt;

&lt;p&gt;文章里提到了一个名词, 叫做牺牲的架构&lt;/p&gt;

&lt;p&gt;很多代码, 是为了解决目前的问题而产生的, 所以, 可以考虑在几年后, 完全抛弃掉这部分代码.
&lt;em&gt;Martin举了一个eBay的例子，他们的做法与牺牲的架构是一致的，他们在一段时间之后把perl脚本移植成了c++代码，又在一段时间之后移植成了java代码。能够支撑1996年ebay的架构不会成为能够支撑2006年ebay的架构。1996年的这一版不能处理2006年的负载压力，但是2006年的版本对于构建和维护来讲太复杂了，而且是针对1996版之后的需求逐步演变而来的。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为了在合适的时机重新构建而构建。它就像抛弃原型，只是代码已经投入使用罢了。当你的业务增长的时候，你可能不得不抛弃之前的一些或者全部的代码库（就像eBay的做法，第二次提到了）。这并不意味着之前的解决方案不好：一点也不，在当时的情况下它们非常恰当。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“性能就是一种特性”。所以团队可以把性能特性和其他的特性一起来排序。最初它的优先级不高，但是开发阶段后期就要提高它的优先级了。&lt;/em&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 02 May 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/05/02/architecture/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/05/02/architecture/</guid>
        
        <category>分布式</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>崇文区看房记录</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这些看房日志都发表于私人微信公众号“笔筒看房日志”上.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;学区房需求，从来没看过东西城的房子，从稍微便宜的东城入手。先考察了老东城，把老东城各个学区的90年之后的房子都列出来了，发现老东城的新房子实在太少（00年之后的）；从而，把目标转向老崇文的东花市-崇文门-前门学区；&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;对房子要求: 不要回迁；新，不要老破小；两居，三居更好；&lt;/li&gt;
  &lt;li&gt;小学 : 崇文小学，培新小学，回民实验小学&lt;/li&gt;
  &lt;li&gt;看了的小区: 新景家园，国瑞城，新裕家园，保利蔷薇&lt;/li&gt;
  &lt;li&gt;中介评价了的小区: 京城仁合、丽水湾畔、金桥国际、天骄园、花市枣苑、富贵园、本家润园 
每家店的中介都会极力推荐某几个小区，排斥其他小区吧，我们的中介就极力推荐了这几个小区，其他的小区都被说了一堆的缺点，后面再说；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结论&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;常年在海淀看学区，伪学区房的单价也到7-8w了，相比崇文广内一带的真学区房真是不值；广内一带的房子比想象中要新且宜居多了；&lt;/li&gt;
  &lt;li&gt;买新房时买大社区很重要，对未来升值以及小区环境维护都有利；&lt;/li&gt;
  &lt;li&gt;看房，一定要到现场看（抢房时特别注意），看房子在本栋楼里的位置，以及与其他楼的相对位置，遮挡可以导致一套房得差价接近200w；&lt;/li&gt;
  &lt;li&gt;关注新景家园，但是目前价格被炒得超级高，没有入手打算；&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-4&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;保利蔷薇—-崇文小学&lt;/h3&gt;

&lt;p&gt;侮辱了保利的名声，小区只有三栋楼，中间几颗树一格小水池就是全部的小区环境了。从两广路到小区要走过一条破旧的小路。小区1号楼和3号楼部分临铁路。不会考虑这个小区了。&lt;/p&gt;

&lt;p&gt;离崇文小学很远，连中介也说下一次改革可能会划到培新小学；&lt;/p&gt;

&lt;p&gt;小区以一居和二居为主，三居整个小区只有18套，在三号楼的两头。三号楼是保利的关系户或者内部房，楼层也相对矮；&lt;/p&gt;

&lt;p&gt;两居，分别看了朝东和西的两居各一套，户型一样，报价奇葩的是朝东的620w，朝西的755w；缺点，小卧室由于外面的遮挡几乎全暗，跟一个隔间一样。&lt;br /&gt;
经验是，房子真的需要现场看，看链家户型图完全看不出遮挡；&lt;/p&gt;

&lt;p&gt;三居，一个紧凑的小三居，103平，每个房间都是明的，户型是真的好，但是！单价太高，高到链家都不敢上架，房子的总价是990w；上一套卖出的价格是900w，带看的小伙也说业主的心气高；&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;新裕家园–培新小学&lt;/h3&gt;
&lt;p&gt;东区是回迁房，看的是西区的两居；划片是培新小学，总感觉培新小学是老崇文第二梯队的，不怎么打算考虑（望了解的人跟我说说培新小学究竟怎么样，跟东花市，崇文小学比起来怎么样，谢谢） 
缺点：小区几乎没有环境，从看门的看出来小区的物业很不好。在房子里从小区的南面望下去是成片的满眼的老平房，拆不动的老平房，。 
优点：离两广路近，两广路西面，户型没遮挡； 
正南两居93平，770w，业主要求全款。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;国瑞城–回民实验小学&lt;/h3&gt;
&lt;p&gt;有商品房和回迁房，无明显区分； 
看的一套回迁房，小三居，东南；中介极力推荐； 
不会再考虑国瑞城的回迁房； 
优点：因为没看到商品房，感受不到这个小区的优点； 
缺点：回迁房区楼间距密，防盗网拉低了整个小区的档次；对口小学时回民小学，中学是崇文门中学（连小哥都说有点次。。）&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;新景家园–崇文小学&lt;/h3&gt;
&lt;p&gt;一期、四期为商品，二三期为回迁；（西区为回迁房，东区为商品房） 
是这一次看房结论会考虑的小区；&lt;/p&gt;

&lt;p&gt;优点：大部分的户型没有遮挡，比较方正；适合住人；四期是棕褐色的楼梯，挺新的；学区好（都是指在老崇文内相对好） 
缺点：人车不分流；&lt;/p&gt;

&lt;p&gt;以上是看了的房；&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;另外还有一些通过中介介绍的信息，仅供参考（肯定是带着排斥的心理倾向的吧）&lt;/p&gt;

&lt;p&gt;1.文汇学区完全是被炒起来的 
中介说:文汇学区内没什么好房，片内的京城仁合、丽水湾畔、金桥国际 
受铁路影响大，过车楼上会颤抖&lt;/p&gt;

&lt;p&gt;2.天骄园 
两居都跟保利蔷薇的两居一样，有明显遮挡&lt;/p&gt;

&lt;p&gt;3.花市枣苑 
物业安保好（中介进不去），塔楼&lt;/p&gt;

&lt;p&gt;4.本家润园 
三期是回迁房，（一期商品房卖得都是大户型没有合适的户型没有看）&lt;/p&gt;

&lt;p&gt;5.富贵园 
回迁房是塔楼，商品房是板楼&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Apr 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/04/17/houseSeeker-Chongwen/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/04/17/houseSeeker-Chongwen/</guid>
        
        <category>日记</category>
        
        <category>生活</category>
        
        <category>房</category>
        
        
      </item>
    
      <item>
        <title>CodeCache引发的一个问题</title>
        <description>&lt;h1 id=&quot;codecache&quot;&gt;CodeCache引发的一个问题&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;概要&lt;/h2&gt;
&lt;p&gt;这个文章记录了一次线上问题的查询过程, 在查询过程中, 学习CodeCache的作用. CodeCache是JIT编译生成的native code的存放空间, 他的大小很可能会影响JVM的性能.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;查询问题的经过&lt;/h2&gt;
&lt;p&gt;本文是&lt;a href=&quot;/2016/03/12/serialize-compare/&quot;&gt;序列化工具对比&lt;/a&gt;的后续. 问题的完整经过是&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线上部署了12个tomcat 实例. 但是经常出现的一个情况是&lt;code class=&quot;highlighter-rouge&quot;&gt;某些&lt;/code&gt;tomcat实例不响应新的请求. 查看catalina日志, 提示”Dubbo Threadpool Exhausted”. 其中, &lt;code class=&quot;highlighter-rouge&quot;&gt;某些&lt;/code&gt;不固定, 可能是12个实例中的任何一个.&lt;/li&gt;
  &lt;li&gt;登陆’Dubbo Threadpool Exhausted’机器上查看jstack, 发现又大量线程在Jackson 进行JSON反序列化处. 机器负载非常低. JVM有频繁的cms gc(每分钟1-2次 CMS). 通过jmap dump出来的数据发现, jackson会反序列化非常大的字符串(最大的有24M). 基于2的现象, 最初怀疑是gc造成了jvm变慢.&lt;/li&gt;
  &lt;li&gt;当时出问题的机器有一个现象, 机器访问速度慢. 如果把机器摘下线, 直接调用接口,不会出现”Dubbo Threadpool Exhausted’. 把机器放上线, 再增加一点流量, 很快就能重现线程池耗尽的现象.  必须要重启, tomcat才能恢复正常. 根据这个猜测, 猜测和gc关系不是很大.&lt;/li&gt;
  &lt;li&gt;为了验证第三点的猜测, 我写了一个代码, 100并发去请求线上的接口, 很快能看见频繁的, 3-5秒钟一次的CMS GC. 但是100并发结束之后, 再用50并发去请求相同的接口, 并不会看见访问变慢的情况. 通过这个验证, 我猜想这个应该并不是因为CMS GC造成了以上的现象.&lt;/li&gt;
  &lt;li&gt;关闭了线上大量使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Jackson进行JSON反序列化处&lt;/code&gt;的功能, 系统再也没有出现线程池耗尽的情况. 难道真的是Jackson 的黑锅?&lt;/li&gt;
  &lt;li&gt;根据线上日志记录, 最大的json 序列化所需要的时间大概是60S左右. 但是我自己在本地测试时, 发现即时是30M的字符串, 所需要的反序列化时间也仅仅是1S左右. — 这个巨大的时间差是为什么呢?&lt;/li&gt;
  &lt;li&gt;在线上的各个tomcat实例里, 写了一个jsp, 用同一个简单的字符串进行反序列化.  出现过线程池耗尽的&lt;code class=&quot;highlighter-rouge&quot;&gt;某些&lt;/code&gt;机器, 速度比没有出现问题的机器要慢很多(耗尽的机器, 速度大概是200ms 没有耗尽的机器, 预计是30ms) , . 重启之后, 所有的机器速度都正常(大概是20ms). —-为什么呢?&lt;/li&gt;
  &lt;li&gt;google “tomcat become slow down”, 发现有人出现了和我一样的问题. 请看这个&lt;a href=&quot;http://stackoverflow.com/questions/14876447/what-could-cause-global-tomcat-jvm-slowdown&quot;&gt;stackoverflow的链接&lt;/a&gt;. 大概的意思是, 需要加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;-XX:ReservedCodeCacheSize=256m&lt;/code&gt;, 扩大CodeCache的Size.&lt;/li&gt;
  &lt;li&gt;在线上选了一台机器, 加上选项&lt;code class=&quot;highlighter-rouge&quot;&gt;-XX:ReservedCodeCacheSize=256m&lt;/code&gt;, 灰度运行了两天, 用第七步的jsp进行验证, 发现速度很快.    今天在这台机器上打开了&lt;code class=&quot;highlighter-rouge&quot;&gt;Jackson进行JSON反序列化处&lt;/code&gt;功能, 坐等灰度的结果&lt;/li&gt;
  &lt;li&gt;运行一天之后, 灰度的结果出来了, 成果不错.  现在已经在所有机器上添加了这个参数, 运行了一天后, 系统稳定.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;codecache-&quot;&gt;CodeCache 是什么?&lt;/h2&gt;

&lt;p&gt;要知道什么是Code Cache,  首先要知道什么是JIT(请参考我的上一篇文章, JIT介绍).  简单的来说, JIT是一种JVM优化技术, 将多次执行的热点JAVA代码编译成native code, 加快运行速度. JIT编译好之后的native code, 就存放在code cache里. CodeCache 也是一段内存空间.&lt;/p&gt;

&lt;h3 id=&quot;codecache--perm&quot;&gt;CodeCache 和 perm区有什么区别&lt;/h3&gt;

&lt;p&gt;CodeCache 和 Permanent Generation 都属于 non-heap memory.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;perm 区存放class的信息, 静态变量, final变量, 类的方法信息等等.&lt;/li&gt;
  &lt;li&gt;CodeCache 区存放的jit编译后的native code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;两段内存空间是分开的.
&lt;img src=&quot;http://static.zybuluo.com/gambol/kf0qnqmh6vttmofkq1onyf0e/jvm-memory-segments1.jpg&quot; alt=&quot;JVM memory structure&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;codecache-1&quot;&gt;CodeCache满了会做什么?&lt;/h3&gt;
&lt;p&gt;随着系统运行, 越来越多的代码会被识别成&lt;strong&gt;热点&lt;/strong&gt;代码, 存放在CodeCache里.  如果CodeCache空间不够, 则会出现”Code Cache满”的情况&lt;/p&gt;

&lt;h4 id=&quot;code-cache&quot;&gt;如何判断code cache满过?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;tomcat可能会打印出一段日志
有些JDK7的版本, 可能并不一定会打印这个信息(我们使用的JDK7U45就没有这条日志)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java HotSpot(TM) 64-Bit Server VM warning: CodeCache is full. Compiler has been disabled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;PrintSafepointStatistics
在JVM启动参数里加上 -XX:+PrintSafepointStatistics. 能看到以下的日志&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;18867.232: HandleFullCodeCache              [     898          1              1    ]      [     1     0     2     0    14    ]  1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个说明, JVM曾经执出现过FullCodeCache的情况, 并进行HandlFullCodeCache操作.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;jvmcodecache-full--jvm-&quot;&gt;JVM收到CodeCache Full 信息之后, JVM 会做什么?&lt;/h4&gt;

&lt;p&gt;当CodeCache空间被用尽之后, jvm compiler就会停止, 不再继续生成native code.&lt;/p&gt;

&lt;p&gt;如果开启了 &lt;em&gt;UseCodeCacheFlushing&lt;/em&gt; 选项,  JVM会启动code cache sweeper, 对CodeCache区进行清理工作. 具体的清理逻辑请查看&lt;a href=&quot;http://e-collection.library.ethz.ch/eserv/eth:8304/eth-8304-01.pdf&quot;&gt;Code Cache Optimizations for Dynamically Compiled Languages&lt;/a&gt;的第2.3.6节.&lt;/p&gt;

&lt;p&gt;在直到CodeCache的剩余空间达到 &lt;em&gt;CodeCacheMinimumFreeSpace&lt;/em&gt; (默认是500k) 之前, JVM在会一直关闭JIT的编译功能.&lt;/p&gt;

&lt;p&gt;JDK6里的&lt;em&gt;UseCodeCacheFlushing&lt;/em&gt; 默认为false, 在JDK7U4之后, &lt;em&gt;UseCodeCacheFlushing&lt;/em&gt;默认是true. 也就是说:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在JDK6里, 如果code cache满了, &lt;strong&gt;默认情况下&lt;/strong&gt;, JVM就一直保留已经编译后的native code, 并且关闭JIT功能,不再进行新的compilation.&lt;/li&gt;
  &lt;li&gt;在JDK7U4之后, 先关闭JIT, 然后对code cache清理.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是, JDK7之后, 关于CodeCache有几个BUG&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;即使code cache清理的很彻底了, 但是JVM仍然不会重新开启JIT功能&lt;/li&gt;
  &lt;li&gt;对code cache的清理工作也能占用大量的cpu资源, 并减慢整个JVM的工作效率&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个已知的bug,  &lt;a href=&quot;http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8006952&quot;&gt;JDK-8006952 : CodeCacheFlushing degenerates VM with excessive codecache freelist iteration&lt;/a&gt;. bug描述的现象和我们遇到的现象基本相同.&lt;/p&gt;

&lt;p&gt;还有一些其他的相关BUG列举如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8012547&quot;&gt;JDK-8012547 : Code cache flushing can get stuck without completing reclamation of memory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8029091&quot;&gt;JDK-8029091 : Bug in calculation of code cache sweeping interval&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上的这些bug在JDK8U33之后, 基本上得到了修复.&lt;/p&gt;

&lt;h3 id=&quot;codecache-2&quot;&gt;CodeCache的相关配置&lt;/h3&gt;

&lt;p&gt;默认情况下, CodeCache 的大小如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;JVM&lt;/th&gt;
      &lt;th&gt;默认的Code cache size&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;32 bit client, JDK8&lt;/td&gt;
      &lt;td&gt;32M&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32-bit server with Tiered Compilation, Java 8&lt;/td&gt;
      &lt;td&gt;240M&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64-bit server with Tiered Compilation, Java 8&lt;/td&gt;
      &lt;td&gt;240M&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32-bit client, Java 7&lt;/td&gt;
      &lt;td&gt;32M&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64-bit server, Java 7&lt;/td&gt;
      &lt;td&gt;48M&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64-bit server with Tiered Compilation, Java 7&lt;/td&gt;
      &lt;td&gt;96M&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们线上使用的是&lt;em&gt;64-bit server with Tiered Compilation&lt;/em&gt;, code cache大小为96M.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;-XX:ReservedCodeCacheSize=XXX&lt;/code&gt; 对Code Cache进行配置. 除此之外, 还有许多有用的配置&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;-XX:ReservedCodeCacheSize=size
 设置的CodeCache最大可用空间. 在JDK8里, 也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-Xmaxjitcodesize=size&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;-XX:CodeCacheMinimumFreeSpace=size
最小需要预留给compiler使用的code cache 大小&lt;/li&gt;
  &lt;li&gt;-XX:InitialCodeCacheSize=size
看名字就知道意思了. 初始化CodeCache大小&lt;/li&gt;
  &lt;li&gt;-XX:+UseCodeCacheFlushing  或者 -XX:-UseCodeCacheFlushing
是否开启code cache 清理的功能. JDK7之后,默认都是true&lt;/li&gt;
  &lt;li&gt;-XX:+PrintFlagsFinal&lt;br /&gt;
在JVM启动时, 打印出所有的JVM相关参数.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于我们线上遇到的这个问题来说, &lt;code class=&quot;highlighter-rouge&quot;&gt;增大ReservedCodeCacheSize空间&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;关闭UseCodeCacheFlushing功能&lt;/code&gt;, 都能绕过JDK7的上述的BUG.&lt;/p&gt;

&lt;h3 id=&quot;codecache-3&quot;&gt;CodeCache的查看&lt;/h3&gt;
&lt;p&gt;在JDK7里, 对于CodeCache的查看以及管理做的不好(活该有bug), 基本上没有提供查看这部分内存使用情况的参数.JDK8里, 可以使用 PrintCodeCache 或者 PrintCodeCacheOnCompilation选项来查看CodeCache的具体使用信息 .&lt;/p&gt;

&lt;p&gt;而JDK7里, 可以用的方法包括&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开启JMX之后, 使用jvisualVM 或者 jconsole查看.&lt;/li&gt;
  &lt;li&gt;在线上写代码, 调用jvm mbean方法来查看. 可以参考https://examples.javacodegeeks.com/enterprise-java/jmx/list-all-jvm-mbeans/. (我目前还没有试过, 代码待补充)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;从线上这个问题的解决过程中, 我们发现, 尤其对于JDK7而言,  JVM的CodeCache是一个值得注意的问题. 如果你的tomcat突然变慢, 并且恰好你的JDK版本是JDK7, 并且恰好你还开启了Tiered compliation, 你很可能命中了JDK7的这个BUG. 解决方法是, 调大ReservedCodeCacheSize 或者 关闭UseCodeCacheFlushing功能.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;最后,强烈推荐这些参考文献.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-jtp12214/&quot;&gt;Dynamic deoptimization 的介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;http://stackoverflow.com/questions/20522870/about-the-dynamic-de-optimization-of-hotspot&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.safaribooksonline.com/library/view/java-performance-the/9781449363512/ch04.html&quot;&gt;JVM调优&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://e-collection.library.ethz.ch/eserv/eth:8304/eth-8304-01.pdf&quot;&gt;code cache详细介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.oracle.com/poonam/entry/why_do_i_get_message&quot;&gt;code cache full的解法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/14876447/what-could-cause-global-tomcat-jvm-slowdown&quot;&gt;为什么tomcat慢了呢?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ggkekas.tumblr.com/&quot;&gt;JVM7的bug描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm&quot;&gt;Codecache 调优&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 30 Mar 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/03/30/CodeCache/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/03/30/CodeCache/</guid>
        
        <category>JVM</category>
        
        <category>技术</category>
        
        <category>JAVA</category>
        
        
      </item>
    
      <item>
        <title>JIT</title>
        <description>&lt;p&gt;﻿#  JIT&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;hotspot-jvm&quot;&gt;Hotspot JVM运行模式&lt;/h2&gt;
&lt;p&gt;JVM有两种模式, -client  和 -server. 从JDK5开始, JVM会根据机器的不同来决定使用哪种模式.&lt;/p&gt;

&lt;p&gt;使用 java  -version可以看到具体所使用的模式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ java -version 
java version &quot;1.8.0_45&quot;
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面命令里,除了  &lt;code class=&quot;highlighter-rouge&quot;&gt;64-Bit Server&lt;/code&gt; 这个吸引我之外, 还有一个东西很有意思.  &lt;code class=&quot;highlighter-rouge&quot;&gt;mixed mode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这是说明, Hotspot VM在默认情况下都是采用解释器+即时编译器的&lt;code class=&quot;highlighter-rouge&quot;&gt;混合&lt;/code&gt;模式共同执行程序.  我们也可以指定不适用混合模式. 使用-Xint 和 -Xcomp即可.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[gambols-mbp15][zhenbao.zhou][~/work/java_works]
$ java -Xcomp -version
java version &quot;1.8.0_45&quot;
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, compiled mode)

[gambols-mbp15][zhenbao.zhou][~/work/java_works]
$ java -Xint -version
java version &quot;1.8.0_45&quot;
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, interpreted mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好,问题来了,解释器(Interpreter) 和 编译器 (compiled)是什么呢? 为什么需要者两个模式?&lt;/p&gt;

&lt;h2 id=&quot;interpreter&quot;&gt;Interpreter解释器&lt;/h2&gt;
&lt;p&gt;### 为什么需要解释器
在JVM早期的发展过程时, JVM的开发人员为了实现&lt;code class=&quot;highlighter-rouge&quot;&gt;跨平台&lt;/code&gt;, 不适用传统的静态编译的方式直接生成本地机器指令，而是实现了解释器(interpreter), 在运行时采用逐行解释字节码执行程序的想法.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;解释器的工作原理&lt;/h3&gt;
&lt;p&gt;在程序运行的过程中, JVM根据预定义的规范对字节码采用逐行解释的方式执行，解释器将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作&lt;/p&gt;

&lt;p&gt;解释器的任务就是负责将字节码指令解释为对应平台的本地机器指令执行。在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Interpreter模块
这个模块模块实现了解释器的核心功能, – 解释&lt;/li&gt;
  &lt;li&gt;Code模块
管理JVM生成的本地机器指令.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;编译器&lt;/h2&gt;
&lt;p&gt;明眼人预计都能看出来, 上面的解释器执行方式效率是有问题的. 因此Hotspot VM有弄了一个编译器. 通常叫做JIT编译器. Hotspot是怎么做的呢? 
关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能.&lt;/p&gt;

&lt;p&gt;有哪些代码会被编译成本地机器指令呢?
1. Invocation Counter  会记录每个方法(method)的执行次数, 当次数大于某一个值的时候, JIT就认为这是一个”热”的方法, 并且编译成本地机器指令(natvie code). 在server模式时,  这个值默认是 10000. 可以通过 -XX:CompileThreshold=10000 来调节.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Back Edge Counter 记录每个循环里代码的执行次数. 如果这个循环里的代码执行次数大鱼某一个值时, 则会把循环里的代码编译成本地机器指令, 并替换掉.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总体来说, 可以由下面的图看出来JIT的执行
&lt;img src=&quot;http://static.zybuluo.com/gambol/gfz5wf5ab9x7kmu2kqmz759b/wKiom1Uwk6aipaOAAACdbZhEZVo906.jpg&quot; alt=&quot;wKiom1Uwk6aipaOAAACdbZhEZVo906.jpg-39.4kB&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jit&quot;&gt;JIT编译器的组成&lt;/h3&gt;
&lt;p&gt;JIT编译器主要由C1模块、Opto模块和Shark模块构成。
- C1模块实现了Client Compiler编译器
- 而Opto模块实现了Server Compiler编译器，因此C2编译器也可以被称之为Opto编译器
- Shark模块中则实现了一个基于LLVM的编译器&lt;/p&gt;

&lt;h2 id=&quot;tiered-compilation&quot;&gt;分层编译策略(Tiered Compilation)&lt;/h2&gt;
&lt;p&gt;默认情况下, 使用Client模式时, 我们使用的是C1编译器. 使用Server模式时, 启用了C2编译器. 
为了加快系统的启动速度, 在JDK7之后, 在Server模式后,默认开启分层编译策略.&lt;/p&gt;

&lt;p&gt;在这种模式下,我们JVM的策略如下:
第0层. 由解释器解释代码执行, 并且解释器关闭代码优化的模块
第1层. 由C1编译器编译成本地机器代码执行, C1编译器执行少量的字节码优化.
第2层. C1编译器进行 invocation 和 backedge counter优化
第3层. C1编译器编译为本地机器指令执行，采集性能数据进行优化措施 (比 第二层慢 35%)
第4层. C2编译器进行完整的优化&lt;/p&gt;

&lt;h1 id=&quot;todo&quot;&gt;TODO&lt;/h1&gt;
&lt;p&gt;没有明白的一个问题:
为什么要搞这么多层?还在继续研究&lt;/p&gt;

&lt;p&gt;另外, jvm7之后, 有许多performance优化的点. 也可以继续学习&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html&lt;/li&gt;
  &lt;li&gt;http://www.slideshare.net/maddocig/tiered&lt;/li&gt;
  &lt;li&gt;http://book.51cto.com/art/201504/472757.htm&lt;/li&gt;
  &lt;li&gt;http://middlewaresnippets.blogspot.hk/2014/11/java-virtual-machine-code-generation.html (待看)&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 27 Mar 2016 20:00:00 +0800</pubDate>
        <link>http://gambol.github.io/2016/03/27/JIT/</link>
        <guid isPermaLink="true">http://gambol.github.io/2016/03/27/JIT/</guid>
        
        <category>技术</category>
        
        <category>JAVA</category>
        
        <category>JVM</category>
        
        <category>JIT</category>
        
        
      </item>
    
  </channel>
</rss>
